"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/gameUtils.ts":
/*!********************************!*\
  !*** ./src/utils/gameUtils.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BIG_BLIND: () => (/* binding */ BIG_BLIND),\n/* harmony export */   community_cards: () => (/* binding */ community_cards),\n/* harmony export */   dealCards: () => (/* binding */ dealCards),\n/* harmony export */   gameStarter: () => (/* binding */ gameStarter),\n/* harmony export */   getNextPlayerIndex: () => (/* binding */ getNextPlayerIndex),\n/* harmony export */   next_actions: () => (/* binding */ next_actions),\n/* harmony export */   next_player: () => (/* binding */ next_player),\n/* harmony export */   should_continue_round: () => (/* binding */ should_continue_round),\n/* harmony export */   updateCards: () => (/* binding */ updateCards)\n/* harmony export */ });\nconst BIG_BLIND = 40;\nconst gameStarter = ()=>{\n    // 1. Position the players\n    const positions = [\n        1,\n        2,\n        3,\n        4,\n        5,\n        6\n    ];\n    // 2. Determine the dealer\n    const dealer = Math.floor(Math.random() * positions.length);\n    // 3. Initialize the small blind and big blind\n    const dsb = {\n        dealer: {\n            player: positions[dealer]\n        },\n        \"small blind\": {\n            player: positions[(dealer + 1) % positions.length],\n            amount: BIG_BLIND / 2\n        },\n        \"big blind\": {\n            player: positions[(dealer + 2) % positions.length],\n            amount: BIG_BLIND\n        }\n    };\n    // 5. Deal cards\n    const { dealtCards, remainingDeck } = dealCards(6, dealer);\n    console.log(\"dealtCards\", dealtCards.length);\n    console.log(\"remainingDeck\", remainingDeck.length);\n    return {\n        data: dealtCards,\n        dsb: dsb,\n        remainingDeck,\n        actions: {\n            preFlop: [],\n            flop: [],\n            turn: [],\n            river: []\n        }\n    };\n};\nconst community_cards = (round, deck)=>{\n    let cardsToDraw;\n    switch(round){\n        case \"flop\":\n            cardsToDraw = 3; // Draw 3 cards for the flop\n            break;\n        case \"turn\":\n        case \"river\":\n            cardsToDraw = 1; // Draw 1 card for turn and river\n            break;\n        default:\n            return {\n                cards: [],\n                remainingDeck: deck\n            }; // For preFlop or invalid rounds, return an empty set of cards\n    }\n    // Draw the specified number of cards from the deck\n    const drawnCards = deck.slice(0, cardsToDraw);\n    const remainingDeck = deck.slice(cardsToDraw);\n    return {\n        cards: drawnCards,\n        remainingDeck\n    };\n};\nconst updateCards = (state, round, playerIndex, action, amount)=>{\n    // Create a copy of the state to ensure immutability\n    const newState = {\n        ...state,\n        actions: {\n            ...state.actions\n        }\n    };\n    // Ensure the actions array for the specified round exists\n    if (!newState.actions[round]) {\n        newState.actions[round] = [];\n    }\n    // Add a new action entry to the round's actions array\n    newState.actions[round].push({\n        player: newState.data[playerIndex].player,\n        action,\n        ...amount !== undefined && {\n            amount\n        }\n    });\n    return newState;\n};\nconst next_actions = (actions, round, currentPlayerIndex)=>{\n    console.log(\"actions in next_actions\", actions);\n    // Extract actions taken in the specified round\n    const roundActions = actions[round] || [];\n    // Determine the highest bet made in the current round\n    const currentBet = Math.max(0, ...roundActions.filter((action)=>[\n            \"bet\",\n            \"raise\",\n            \"call\"\n        ].includes(action.action)).map((action)=>action.amount || 0));\n    // Calculate the total amount the current player has contributed in this round\n    const playerBet = roundActions.filter((action)=>action.playerIndex === currentPlayerIndex).reduce((sum, action)=>sum + (action.amount || 0), 0);\n    // Initialize possible actions for the player\n    const availableActions = [\n        \"fold\"\n    ];\n    // Determine available actions based on the current betting state\n    if (currentBet === 0) {\n        // No existing bet in the round: player can \"check\" or \"bet\"\n        availableActions.push(\"check\", \"bet\");\n    } else {\n        // There's an existing bet in the round\n        if (playerBet < currentBet) {\n            availableActions.push(\"call\"); // Player can call to match the current bet\n        }\n        if (playerBet === currentBet) {\n            availableActions.push(\"check\"); // Player can check if they’ve matched the bet\n        }\n        if (playerBet < currentBet) {\n            availableActions.push(\"raise\"); // Player can raise if they have chips to increase the current bet\n        }\n    }\n    // Add \"all-in\" as an option\n    availableActions.push(\"all-in\");\n    return availableActions;\n};\nconst should_continue_round = (actions, data, currentRound)=>{\n    // Get the list of actions for the current round\n    const roundActions = actions[currentRound];\n    // Check if every player in `data` has made an action in the current round\n    const allPlayersActed = data.every((player)=>roundActions.some((action)=>action.player === player.player));\n    // Calculate the total bet amount for each player in the current round\n    const playerBetTotals = {};\n    roundActions.forEach((action)=>{\n        if ([\n            \"bet\",\n            \"raise\",\n            \"call\"\n        ].includes(action.action) && action.amount !== undefined) {\n            playerBetTotals[action.player] = (playerBetTotals[action.player] || 0) + action.amount;\n        }\n    });\n    // Get all unique bet totals from players who acted in the round\n    const uniqueBetTotals = new Set(Object.values(playerBetTotals));\n    // All players must act, and their total bet amounts must be equal\n    return allPlayersActed && uniqueBetTotals.size === 1;\n};\nconst getNextPlayerIndex = (playerIndex, data, currentRound)=>{\n    const rounds = [\n        \"preFlop\",\n        \"flop\",\n        \"turn\",\n        \"river\"\n    ];\n    const currentRoundIndex = rounds.indexOf(currentRound);\n    // Step 1: Identify all players who have folded in any round up to the current round\n    const foldedPlayers = new Set();\n    for(let i = 0; i <= currentRoundIndex; i++){\n        const round = rounds[i];\n        if (data.actions[round]) {\n            data.actions[round].forEach((action)=>{\n                if (action.action === \"fold\") {\n                    foldedPlayers.add(action.player);\n                }\n            });\n        }\n    }\n    // Step 2: Find the next active player index\n    const players = data.players; // Assuming `data.players` is an array of player objects or IDs\n    let nextPlayerIndex = playerIndex;\n    do {\n        nextPlayerIndex = (nextPlayerIndex + 1) % players.length; // Move to the next player in a circular manner\n    }while (foldedPlayers.has(players[nextPlayerIndex]) && nextPlayerIndex !== playerIndex);\n    // If we looped back to the original playerIndex without finding an active player, return -1 (or handle as needed)\n    if (nextPlayerIndex === playerIndex && foldedPlayers.has(players[nextPlayerIndex])) {\n        return -1; // No eligible player found\n    }\n    return nextPlayerIndex;\n};\n// Helper function to generate dealt cards for each player\nconst dealCards = function() {\n    let players = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6, dealer = arguments.length > 1 ? arguments[1] : void 0;\n    const suits = [\n        \"♠\",\n        \"♥\",\n        \"♦\",\n        \"♣\"\n    ];\n    const values = [\n        \"A\",\n        \"K\",\n        \"Q\",\n        \"J\",\n        \"10\",\n        \"9\",\n        \"8\",\n        \"7\",\n        \"6\",\n        \"5\",\n        \"4\",\n        \"3\",\n        \"2\"\n    ];\n    // Generate a full deck of 52 cards\n    const deck = [];\n    for (const suit of suits){\n        for (const value of values){\n            deck.push(\"\".concat(value).concat(suit));\n        }\n    }\n    // Shuffle the deck\n    const shuffledDeck = deck.sort(()=>Math.random() - 0.5);\n    // Deal two cards to each player, starting from the player after the dealer\n    const dealtCards = [];\n    const startingPosition = (dealer + 1) % players;\n    for(let i = 0; i < players; i++){\n        const position = (startingPosition + i) % players;\n        const playerCards = [\n            shuffledDeck.pop(),\n            shuffledDeck.pop()\n        ]; // Deal two cards per player\n        dealtCards.push({\n            player: position + 1,\n            dealt: playerCards.join(\" \")\n        });\n    }\n    // Remaining deck after dealing\n    const remainingDeck = [\n        ...shuffledDeck\n    ];\n    return {\n        dealtCards,\n        remainingDeck\n    };\n};\n// Helper function to tell the next player to act\nconst next_player = (state, currentPlayerIndex)=>{\n    const { dealtCards } = state; // Access the list of players from the state\n    const numPlayers = dealtCards.length;\n    // Find the highest bet made in the current stage\n    const highestBet = Math.max(...dealtCards.map((player)=>player.bet || 0) // Assuming `bet` property stores each player’s current bet amount\n    );\n    // Start from the next player and loop until finding an eligible player\n    let nextIndex = (currentPlayerIndex + 1) % numPlayers;\n    while(nextIndex !== currentPlayerIndex){\n        const player = dealtCards[nextIndex];\n        // Check if player has not folded and their bet is not equal to the highest bet\n        if (!player.folded && (player.bet || 0) < highestBet) {\n            return nextIndex; // Return the index of the next player to act\n        }\n        // Move to the next player\n        nextIndex = (nextIndex + 1) % numPlayers;\n    }\n    // If no eligible player found, return -1 to indicate the round is complete\n    return -1;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9nYW1lVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRU8sTUFBTUEsWUFBWSxHQUFHO0FBRXJCLE1BQU1DLGNBQWM7SUFDekIsMEJBQTBCO0lBQzFCLE1BQU1DLFlBQVk7UUFBQztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7S0FBRTtJQUVwQywwQkFBMEI7SUFDMUIsTUFBTUMsU0FBU0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUtKLFVBQVVLLE1BQU07SUFFMUQsOENBQThDO0lBQzlDLE1BQU1DLE1BQU07UUFDVkwsUUFBUTtZQUFFTSxRQUFRUCxTQUFTLENBQUNDLE9BQU87UUFBQztRQUNwQyxlQUFlO1lBQ2JNLFFBQVFQLFNBQVMsQ0FBQyxDQUFDQyxTQUFTLEtBQUtELFVBQVVLLE1BQU0sQ0FBQztZQUNsREcsUUFBUVYsWUFBWTtRQUN0QjtRQUNBLGFBQWE7WUFDWFMsUUFBUVAsU0FBUyxDQUFDLENBQUNDLFNBQVMsS0FBS0QsVUFBVUssTUFBTSxDQUFDO1lBQ2xERyxRQUFRVjtRQUNWO0lBQ0Y7SUFFQSxnQkFBZ0I7SUFDaEIsTUFBTSxFQUFFVyxVQUFVLEVBQUVDLGFBQWEsRUFBRSxHQUFHQyxVQUFVLEdBQUdWO0lBQ25EVyxRQUFRQyxHQUFHLENBQUMsY0FBY0osV0FBV0osTUFBTTtJQUMzQ08sUUFBUUMsR0FBRyxDQUFDLGlCQUFpQkgsY0FBY0wsTUFBTTtJQUVqRCxPQUFPO1FBQ0xTLE1BQU1MO1FBQ05ILEtBQUtBO1FBQ0xJO1FBQ0FLLFNBQVM7WUFDUEMsU0FBUyxFQUFFO1lBQ1hDLE1BQU0sRUFBRTtZQUNSQyxNQUFNLEVBQUU7WUFDUkMsT0FBTyxFQUFFO1FBQ1g7SUFDRjtBQUNGLEVBQUU7QUFFSyxNQUFNQyxrQkFBa0IsQ0FBQ0MsT0FBY0M7SUFDNUMsSUFBSUM7SUFFSixPQUFRRjtRQUNOLEtBQUs7WUFDSEUsY0FBYyxHQUFHLDRCQUE0QjtZQUM3QztR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QUFPRixZQUFZRyxJQUFJLENBQUM7UUFDMUI7SUFDRjtJQUVBLCtCQUErQjtJQUMvQixNQUFNcEUsZ0JBQWdCO1dBQUk2RDtLQUFhO0lBRXZDLE9BQU87UUFDTDlEO1FBQ0FDO0lBQ0Y7QUFDRixFQUFFO0FBRUYsaURBQWlEO0FBQzFDLE1BQU1xRSxjQUFjLENBQUNuRCxPQUFZTztJQUN0QyxNQUFNLEVBQUUxQixVQUFVLEVBQUUsR0FBR21CLE9BQU8sNENBQTRDO0lBQzFFLE1BQU1vRCxhQUFhdkUsV0FBV0osTUFBTTtJQUVwQyxpREFBaUQ7SUFDakQsTUFBTTRFLGFBQWEvRSxLQUFLb0MsR0FBRyxJQUN0QjdCLFdBQVdnQyxHQUFHLENBQUMsQ0FBQ2xDLFNBQVdBLE9BQU8yRSxHQUFHLElBQUksR0FBRyxrRUFBa0U7O0lBR25ILHVFQUF1RTtJQUN2RSxJQUFJQyxZQUFZLENBQUNoRCxxQkFBcUIsS0FBSzZDO0lBRTNDLE1BQU9HLGNBQWNoRCxtQkFBb0I7UUFDdkMsTUFBTTVCLFNBQVNFLFVBQVUsQ0FBQzBFLFVBQVU7UUFFcEMsK0VBQStFO1FBQy9FLElBQUksQ0FBQzVFLE9BQU82RSxNQUFNLElBQUksQ0FBQzdFLE9BQU8yRSxHQUFHLElBQUksS0FBS0QsWUFBWTtZQUNwRCxPQUFPRSxXQUFXLDZDQUE2QztRQUNqRTtRQUVBLDBCQUEwQjtRQUMxQkEsWUFBWSxDQUFDQSxZQUFZLEtBQUtIO0lBQ2hDO0lBRUEsMkVBQTJFO0lBQzNFLE9BQU8sQ0FBQztBQUNWLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvZ2FtZVV0aWxzLnRzPzViOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aW9uLCBSb3VuZCB9IGZyb20gXCJAL2FwcC9wYWdlXCI7XHJcblxyXG5leHBvcnQgY29uc3QgQklHX0JMSU5EID0gNDA7XHJcblxyXG5leHBvcnQgY29uc3QgZ2FtZVN0YXJ0ZXIgPSAoKSA9PiB7XHJcbiAgLy8gMS4gUG9zaXRpb24gdGhlIHBsYXllcnNcclxuICBjb25zdCBwb3NpdGlvbnMgPSBbMSwgMiwgMywgNCwgNSwgNl07XHJcblxyXG4gIC8vIDIuIERldGVybWluZSB0aGUgZGVhbGVyXHJcbiAgY29uc3QgZGVhbGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9zaXRpb25zLmxlbmd0aCk7XHJcblxyXG4gIC8vIDMuIEluaXRpYWxpemUgdGhlIHNtYWxsIGJsaW5kIGFuZCBiaWcgYmxpbmRcclxuICBjb25zdCBkc2IgPSB7XHJcbiAgICBkZWFsZXI6IHsgcGxheWVyOiBwb3NpdGlvbnNbZGVhbGVyXSB9LFxyXG4gICAgXCJzbWFsbCBibGluZFwiOiB7XHJcbiAgICAgIHBsYXllcjogcG9zaXRpb25zWyhkZWFsZXIgKyAxKSAlIHBvc2l0aW9ucy5sZW5ndGhdLFxyXG4gICAgICBhbW91bnQ6IEJJR19CTElORCAvIDIsXHJcbiAgICB9LFxyXG4gICAgXCJiaWcgYmxpbmRcIjoge1xyXG4gICAgICBwbGF5ZXI6IHBvc2l0aW9uc1soZGVhbGVyICsgMikgJSBwb3NpdGlvbnMubGVuZ3RoXSxcclxuICAgICAgYW1vdW50OiBCSUdfQkxJTkQsXHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIC8vIDUuIERlYWwgY2FyZHNcclxuICBjb25zdCB7IGRlYWx0Q2FyZHMsIHJlbWFpbmluZ0RlY2sgfSA9IGRlYWxDYXJkcyg2LCBkZWFsZXIpO1xyXG4gIGNvbnNvbGUubG9nKFwiZGVhbHRDYXJkc1wiLCBkZWFsdENhcmRzLmxlbmd0aCk7XHJcbiAgY29uc29sZS5sb2coXCJyZW1haW5pbmdEZWNrXCIsIHJlbWFpbmluZ0RlY2subGVuZ3RoKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGRhdGE6IGRlYWx0Q2FyZHMsXHJcbiAgICBkc2I6IGRzYixcclxuICAgIHJlbWFpbmluZ0RlY2ssXHJcbiAgICBhY3Rpb25zOiB7XHJcbiAgICAgIHByZUZsb3A6IFtdLFxyXG4gICAgICBmbG9wOiBbXSxcclxuICAgICAgdHVybjogW10sXHJcbiAgICAgIHJpdmVyOiBbXSxcclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb21tdW5pdHlfY2FyZHMgPSAocm91bmQ6IFJvdW5kLCBkZWNrOiBzdHJpbmdbXSkgPT4ge1xyXG4gIGxldCBjYXJkc1RvRHJhdztcclxuXHJcbiAgc3dpdGNoIChyb3VuZCkge1xyXG4gICAgY2FzZSBcImZsb3BcIjpcclxuICAgICAgY2FyZHNUb0RyYXcgPSAzOyAvLyBEcmF3IDMgY2FyZHMgZm9yIHRoZSBmbG9wXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcInR1cm5cIjpcclxuICAgIGNhc2UgXCJyaXZlclwiOlxyXG4gICAgICBjYXJkc1RvRHJhdyA9IDE7IC8vIERyYXcgMSBjYXJkIGZvciB0dXJuIGFuZCByaXZlclxyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB7IGNhcmRzOiBbXSwgcmVtYWluaW5nRGVjazogZGVjayB9OyAvLyBGb3IgcHJlRmxvcCBvciBpbnZhbGlkIHJvdW5kcywgcmV0dXJuIGFuIGVtcHR5IHNldCBvZiBjYXJkc1xyXG4gIH1cclxuXHJcbiAgLy8gRHJhdyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBjYXJkcyBmcm9tIHRoZSBkZWNrXHJcbiAgY29uc3QgZHJhd25DYXJkcyA9IGRlY2suc2xpY2UoMCwgY2FyZHNUb0RyYXcpO1xyXG4gIGNvbnN0IHJlbWFpbmluZ0RlY2sgPSBkZWNrLnNsaWNlKGNhcmRzVG9EcmF3KTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGNhcmRzOiBkcmF3bkNhcmRzLFxyXG4gICAgcmVtYWluaW5nRGVjayxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUNhcmRzID0gKFxyXG4gIHN0YXRlOiBhbnksXHJcbiAgcm91bmQ6IHN0cmluZyxcclxuICBwbGF5ZXJJbmRleDogbnVtYmVyLFxyXG4gIGFjdGlvbjogc3RyaW5nLFxyXG4gIGFtb3VudD86IG51bWJlclxyXG4pID0+IHtcclxuICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBzdGF0ZSB0byBlbnN1cmUgaW1tdXRhYmlsaXR5XHJcbiAgY29uc3QgbmV3U3RhdGUgPSB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIGFjdGlvbnM6IHsgLi4uc3RhdGUuYWN0aW9ucyB9LFxyXG4gIH07XHJcblxyXG4gIC8vIEVuc3VyZSB0aGUgYWN0aW9ucyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCByb3VuZCBleGlzdHNcclxuICBpZiAoIW5ld1N0YXRlLmFjdGlvbnNbcm91bmRdKSB7XHJcbiAgICBuZXdTdGF0ZS5hY3Rpb25zW3JvdW5kXSA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIGEgbmV3IGFjdGlvbiBlbnRyeSB0byB0aGUgcm91bmQncyBhY3Rpb25zIGFycmF5XHJcbiAgbmV3U3RhdGUuYWN0aW9uc1tyb3VuZF0ucHVzaCh7XHJcbiAgICBwbGF5ZXI6IG5ld1N0YXRlLmRhdGFbcGxheWVySW5kZXhdLnBsYXllcixcclxuICAgIGFjdGlvbixcclxuICAgIC4uLihhbW91bnQgIT09IHVuZGVmaW5lZCAmJiB7IGFtb3VudCB9KSwgLy8gQ29uZGl0aW9uYWxseSBhZGQgYW1vdW50IGlmIHByb3ZpZGVkXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufTtcclxuZXhwb3J0IGNvbnN0IG5leHRfYWN0aW9ucyA9IChcclxuICBhY3Rpb25zOiB7XHJcbiAgICBba2V5IGluIFJvdW5kXTogQXJyYXk8e1xyXG4gICAgICBwbGF5ZXJJbmRleDogbnVtYmVyO1xyXG4gICAgICBhY3Rpb246IHN0cmluZztcclxuICAgICAgYW1vdW50PzogbnVtYmVyO1xyXG4gICAgfT47XHJcbiAgfSxcclxuICByb3VuZDogUm91bmQsXHJcbiAgY3VycmVudFBsYXllckluZGV4OiBudW1iZXJcclxuKTogQWN0aW9uW10gPT4ge1xyXG4gIGNvbnNvbGUubG9nKFwiYWN0aW9ucyBpbiBuZXh0X2FjdGlvbnNcIiwgYWN0aW9ucyk7XHJcbiAgLy8gRXh0cmFjdCBhY3Rpb25zIHRha2VuIGluIHRoZSBzcGVjaWZpZWQgcm91bmRcclxuICBjb25zdCByb3VuZEFjdGlvbnMgPSBhY3Rpb25zW3JvdW5kXSB8fCBbXTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHRoZSBoaWdoZXN0IGJldCBtYWRlIGluIHRoZSBjdXJyZW50IHJvdW5kXHJcbiAgY29uc3QgY3VycmVudEJldCA9IE1hdGgubWF4KFxyXG4gICAgMCxcclxuICAgIC4uLnJvdW5kQWN0aW9uc1xyXG4gICAgICAuZmlsdGVyKChhY3Rpb24pID0+IFtcImJldFwiLCBcInJhaXNlXCIsIFwiY2FsbFwiXS5pbmNsdWRlcyhhY3Rpb24uYWN0aW9uKSlcclxuICAgICAgLm1hcCgoYWN0aW9uKSA9PiBhY3Rpb24uYW1vdW50IHx8IDApXHJcbiAgKTtcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBhbW91bnQgdGhlIGN1cnJlbnQgcGxheWVyIGhhcyBjb250cmlidXRlZCBpbiB0aGlzIHJvdW5kXHJcbiAgY29uc3QgcGxheWVyQmV0ID0gcm91bmRBY3Rpb25zXHJcbiAgICAuZmlsdGVyKChhY3Rpb24pID0+IGFjdGlvbi5wbGF5ZXJJbmRleCA9PT0gY3VycmVudFBsYXllckluZGV4KVxyXG4gICAgLnJlZHVjZSgoc3VtLCBhY3Rpb24pID0+IHN1bSArIChhY3Rpb24uYW1vdW50IHx8IDApLCAwKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwb3NzaWJsZSBhY3Rpb25zIGZvciB0aGUgcGxheWVyXHJcbiAgY29uc3QgYXZhaWxhYmxlQWN0aW9uczogQWN0aW9uW10gPSBbXCJmb2xkXCJdO1xyXG5cclxuICAvLyBEZXRlcm1pbmUgYXZhaWxhYmxlIGFjdGlvbnMgYmFzZWQgb24gdGhlIGN1cnJlbnQgYmV0dGluZyBzdGF0ZVxyXG4gIGlmIChjdXJyZW50QmV0ID09PSAwKSB7XHJcbiAgICAvLyBObyBleGlzdGluZyBiZXQgaW4gdGhlIHJvdW5kOiBwbGF5ZXIgY2FuIFwiY2hlY2tcIiBvciBcImJldFwiXHJcbiAgICBhdmFpbGFibGVBY3Rpb25zLnB1c2goXCJjaGVja1wiLCBcImJldFwiKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gVGhlcmUncyBhbiBleGlzdGluZyBiZXQgaW4gdGhlIHJvdW5kXHJcbiAgICBpZiAocGxheWVyQmV0IDwgY3VycmVudEJldCkge1xyXG4gICAgICBhdmFpbGFibGVBY3Rpb25zLnB1c2goXCJjYWxsXCIpOyAvLyBQbGF5ZXIgY2FuIGNhbGwgdG8gbWF0Y2ggdGhlIGN1cnJlbnQgYmV0XHJcbiAgICB9XHJcbiAgICBpZiAocGxheWVyQmV0ID09PSBjdXJyZW50QmV0KSB7XHJcbiAgICAgIGF2YWlsYWJsZUFjdGlvbnMucHVzaChcImNoZWNrXCIpOyAvLyBQbGF5ZXIgY2FuIGNoZWNrIGlmIHRoZXnigJl2ZSBtYXRjaGVkIHRoZSBiZXRcclxuICAgIH1cclxuICAgIGlmIChwbGF5ZXJCZXQgPCBjdXJyZW50QmV0KSB7XHJcbiAgICAgIGF2YWlsYWJsZUFjdGlvbnMucHVzaChcInJhaXNlXCIpOyAvLyBQbGF5ZXIgY2FuIHJhaXNlIGlmIHRoZXkgaGF2ZSBjaGlwcyB0byBpbmNyZWFzZSB0aGUgY3VycmVudCBiZXRcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBcImFsbC1pblwiIGFzIGFuIG9wdGlvblxyXG4gIGF2YWlsYWJsZUFjdGlvbnMucHVzaChcImFsbC1pblwiKTtcclxuXHJcbiAgcmV0dXJuIGF2YWlsYWJsZUFjdGlvbnM7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2hvdWxkX2NvbnRpbnVlX3JvdW5kID0gKFxyXG4gIGFjdGlvbnM6IHtcclxuICAgIFtrZXkgaW4gUm91bmRdOiBBcnJheTx7IHBsYXllcjogc3RyaW5nOyBhY3Rpb246IHN0cmluZzsgYW1vdW50PzogbnVtYmVyIH0+O1xyXG4gIH0sXHJcbiAgZGF0YTogYW55W10sXHJcbiAgY3VycmVudFJvdW5kOiBSb3VuZFxyXG4pID0+IHtcclxuICAvLyBHZXQgdGhlIGxpc3Qgb2YgYWN0aW9ucyBmb3IgdGhlIGN1cnJlbnQgcm91bmRcclxuICBjb25zdCByb3VuZEFjdGlvbnMgPSBhY3Rpb25zW2N1cnJlbnRSb3VuZF07XHJcblxyXG4gIC8vIENoZWNrIGlmIGV2ZXJ5IHBsYXllciBpbiBgZGF0YWAgaGFzIG1hZGUgYW4gYWN0aW9uIGluIHRoZSBjdXJyZW50IHJvdW5kXHJcbiAgY29uc3QgYWxsUGxheWVyc0FjdGVkID0gZGF0YS5ldmVyeSgocGxheWVyKSA9PlxyXG4gICAgcm91bmRBY3Rpb25zLnNvbWUoKGFjdGlvbikgPT4gYWN0aW9uLnBsYXllciA9PT0gcGxheWVyLnBsYXllcilcclxuICApO1xyXG5cclxuICAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIGJldCBhbW91bnQgZm9yIGVhY2ggcGxheWVyIGluIHRoZSBjdXJyZW50IHJvdW5kXHJcbiAgY29uc3QgcGxheWVyQmV0VG90YWxzOiB7IFtwbGF5ZXI6IHN0cmluZ106IG51bWJlciB9ID0ge307XHJcblxyXG4gIHJvdW5kQWN0aW9ucy5mb3JFYWNoKChhY3Rpb24pID0+IHtcclxuICAgIGlmIChcclxuICAgICAgW1wiYmV0XCIsIFwicmFpc2VcIiwgXCJjYWxsXCJdLmluY2x1ZGVzKGFjdGlvbi5hY3Rpb24pICYmXHJcbiAgICAgIGFjdGlvbi5hbW91bnQgIT09IHVuZGVmaW5lZFxyXG4gICAgKSB7XHJcbiAgICAgIHBsYXllckJldFRvdGFsc1thY3Rpb24ucGxheWVyXSA9XHJcbiAgICAgICAgKHBsYXllckJldFRvdGFsc1thY3Rpb24ucGxheWVyXSB8fCAwKSArIGFjdGlvbi5hbW91bnQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEdldCBhbGwgdW5pcXVlIGJldCB0b3RhbHMgZnJvbSBwbGF5ZXJzIHdobyBhY3RlZCBpbiB0aGUgcm91bmRcclxuICBjb25zdCB1bmlxdWVCZXRUb3RhbHMgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMocGxheWVyQmV0VG90YWxzKSk7XHJcblxyXG4gIC8vIEFsbCBwbGF5ZXJzIG11c3QgYWN0LCBhbmQgdGhlaXIgdG90YWwgYmV0IGFtb3VudHMgbXVzdCBiZSBlcXVhbFxyXG4gIHJldHVybiBhbGxQbGF5ZXJzQWN0ZWQgJiYgdW5pcXVlQmV0VG90YWxzLnNpemUgPT09IDE7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0TmV4dFBsYXllckluZGV4ID0gKFxyXG4gIHBsYXllckluZGV4OiBudW1iZXIsXHJcbiAgZGF0YTogYW55LFxyXG4gIGN1cnJlbnRSb3VuZDogUm91bmRcclxuKSA9PiB7XHJcbiAgY29uc3Qgcm91bmRzID0gW1wicHJlRmxvcFwiLCBcImZsb3BcIiwgXCJ0dXJuXCIsIFwicml2ZXJcIl07XHJcbiAgY29uc3QgY3VycmVudFJvdW5kSW5kZXggPSByb3VuZHMuaW5kZXhPZihjdXJyZW50Um91bmQpO1xyXG5cclxuICAvLyBTdGVwIDE6IElkZW50aWZ5IGFsbCBwbGF5ZXJzIHdobyBoYXZlIGZvbGRlZCBpbiBhbnkgcm91bmQgdXAgdG8gdGhlIGN1cnJlbnQgcm91bmRcclxuICBjb25zdCBmb2xkZWRQbGF5ZXJzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGN1cnJlbnRSb3VuZEluZGV4OyBpKyspIHtcclxuICAgIGNvbnN0IHJvdW5kID0gcm91bmRzW2ldO1xyXG4gICAgaWYgKGRhdGEuYWN0aW9uc1tyb3VuZF0pIHtcclxuICAgICAgZGF0YS5hY3Rpb25zW3JvdW5kXS5mb3JFYWNoKFxyXG4gICAgICAgIChhY3Rpb246IHsgcGxheWVyOiBzdHJpbmc7IGFjdGlvbjogc3RyaW5nIH0pID0+IHtcclxuICAgICAgICAgIGlmIChhY3Rpb24uYWN0aW9uID09PSBcImZvbGRcIikge1xyXG4gICAgICAgICAgICBmb2xkZWRQbGF5ZXJzLmFkZChhY3Rpb24ucGxheWVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTdGVwIDI6IEZpbmQgdGhlIG5leHQgYWN0aXZlIHBsYXllciBpbmRleFxyXG4gIGNvbnN0IHBsYXllcnMgPSBkYXRhLnBsYXllcnM7IC8vIEFzc3VtaW5nIGBkYXRhLnBsYXllcnNgIGlzIGFuIGFycmF5IG9mIHBsYXllciBvYmplY3RzIG9yIElEc1xyXG4gIGxldCBuZXh0UGxheWVySW5kZXggPSBwbGF5ZXJJbmRleDtcclxuXHJcbiAgZG8ge1xyXG4gICAgbmV4dFBsYXllckluZGV4ID0gKG5leHRQbGF5ZXJJbmRleCArIDEpICUgcGxheWVycy5sZW5ndGg7IC8vIE1vdmUgdG8gdGhlIG5leHQgcGxheWVyIGluIGEgY2lyY3VsYXIgbWFubmVyXHJcbiAgfSB3aGlsZSAoXHJcbiAgICBmb2xkZWRQbGF5ZXJzLmhhcyhwbGF5ZXJzW25leHRQbGF5ZXJJbmRleF0pICYmXHJcbiAgICBuZXh0UGxheWVySW5kZXggIT09IHBsYXllckluZGV4XHJcbiAgKTtcclxuXHJcbiAgLy8gSWYgd2UgbG9vcGVkIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHBsYXllckluZGV4IHdpdGhvdXQgZmluZGluZyBhbiBhY3RpdmUgcGxheWVyLCByZXR1cm4gLTEgKG9yIGhhbmRsZSBhcyBuZWVkZWQpXHJcbiAgaWYgKFxyXG4gICAgbmV4dFBsYXllckluZGV4ID09PSBwbGF5ZXJJbmRleCAmJlxyXG4gICAgZm9sZGVkUGxheWVycy5oYXMocGxheWVyc1tuZXh0UGxheWVySW5kZXhdKVxyXG4gICkge1xyXG4gICAgcmV0dXJuIC0xOyAvLyBObyBlbGlnaWJsZSBwbGF5ZXIgZm91bmRcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXh0UGxheWVySW5kZXg7XHJcbn07XHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBkZWFsdCBjYXJkcyBmb3IgZWFjaCBwbGF5ZXJcclxuZXhwb3J0IGNvbnN0IGRlYWxDYXJkcyA9IChwbGF5ZXJzID0gNiwgZGVhbGVyOiBudW1iZXIpID0+IHtcclxuICBjb25zdCBzdWl0cyA9IFtcIuKZoFwiLCBcIuKZpVwiLCBcIuKZplwiLCBcIuKZo1wiXTtcclxuICBjb25zdCB2YWx1ZXMgPSBbXHJcbiAgICBcIkFcIixcclxuICAgIFwiS1wiLFxyXG4gICAgXCJRXCIsXHJcbiAgICBcIkpcIixcclxuICAgIFwiMTBcIixcclxuICAgIFwiOVwiLFxyXG4gICAgXCI4XCIsXHJcbiAgICBcIjdcIixcclxuICAgIFwiNlwiLFxyXG4gICAgXCI1XCIsXHJcbiAgICBcIjRcIixcclxuICAgIFwiM1wiLFxyXG4gICAgXCIyXCIsXHJcbiAgXTtcclxuXHJcbiAgLy8gR2VuZXJhdGUgYSBmdWxsIGRlY2sgb2YgNTIgY2FyZHNcclxuICBjb25zdCBkZWNrID0gW107XHJcbiAgZm9yIChjb25zdCBzdWl0IG9mIHN1aXRzKSB7XHJcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xyXG4gICAgICBkZWNrLnB1c2goYCR7dmFsdWV9JHtzdWl0fWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2h1ZmZsZSB0aGUgZGVja1xyXG4gIGNvbnN0IHNodWZmbGVkRGVjayA9IGRlY2suc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcclxuXHJcbiAgLy8gRGVhbCB0d28gY2FyZHMgdG8gZWFjaCBwbGF5ZXIsIHN0YXJ0aW5nIGZyb20gdGhlIHBsYXllciBhZnRlciB0aGUgZGVhbGVyXHJcbiAgY29uc3QgZGVhbHRDYXJkcyA9IFtdO1xyXG4gIGNvbnN0IHN0YXJ0aW5nUG9zaXRpb24gPSAoZGVhbGVyICsgMSkgJSBwbGF5ZXJzO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYXllcnM7IGkrKykge1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSAoc3RhcnRpbmdQb3NpdGlvbiArIGkpICUgcGxheWVycztcclxuICAgIGNvbnN0IHBsYXllckNhcmRzID0gW3NodWZmbGVkRGVjay5wb3AoKSwgc2h1ZmZsZWREZWNrLnBvcCgpXTsgLy8gRGVhbCB0d28gY2FyZHMgcGVyIHBsYXllclxyXG4gICAgZGVhbHRDYXJkcy5wdXNoKHtcclxuICAgICAgcGxheWVyOiBwb3NpdGlvbiArIDEsIC8vIFBvc2l0aW9ucyBhcmUgMS1pbmRleGVkICgxLCAyLCAuLi4sIDYpXHJcbiAgICAgIGRlYWx0OiBwbGF5ZXJDYXJkcy5qb2luKFwiIFwiKSwgLy8gRm9ybWF0IGNhcmRzIGFzIFwiQWMgS2hcIlxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1haW5pbmcgZGVjayBhZnRlciBkZWFsaW5nXHJcbiAgY29uc3QgcmVtYWluaW5nRGVjayA9IFsuLi5zaHVmZmxlZERlY2tdO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZGVhbHRDYXJkcyxcclxuICAgIHJlbWFpbmluZ0RlY2ssXHJcbiAgfTtcclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byB0ZWxsIHRoZSBuZXh0IHBsYXllciB0byBhY3RcclxuZXhwb3J0IGNvbnN0IG5leHRfcGxheWVyID0gKHN0YXRlOiBhbnksIGN1cnJlbnRQbGF5ZXJJbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgY29uc3QgeyBkZWFsdENhcmRzIH0gPSBzdGF0ZTsgLy8gQWNjZXNzIHRoZSBsaXN0IG9mIHBsYXllcnMgZnJvbSB0aGUgc3RhdGVcclxuICBjb25zdCBudW1QbGF5ZXJzID0gZGVhbHRDYXJkcy5sZW5ndGg7XHJcblxyXG4gIC8vIEZpbmQgdGhlIGhpZ2hlc3QgYmV0IG1hZGUgaW4gdGhlIGN1cnJlbnQgc3RhZ2VcclxuICBjb25zdCBoaWdoZXN0QmV0ID0gTWF0aC5tYXgoXHJcbiAgICAuLi5kZWFsdENhcmRzLm1hcCgocGxheWVyKSA9PiBwbGF5ZXIuYmV0IHx8IDApIC8vIEFzc3VtaW5nIGBiZXRgIHByb3BlcnR5IHN0b3JlcyBlYWNoIHBsYXllcuKAmXMgY3VycmVudCBiZXQgYW1vdW50XHJcbiAgKTtcclxuXHJcbiAgLy8gU3RhcnQgZnJvbSB0aGUgbmV4dCBwbGF5ZXIgYW5kIGxvb3AgdW50aWwgZmluZGluZyBhbiBlbGlnaWJsZSBwbGF5ZXJcclxuICBsZXQgbmV4dEluZGV4ID0gKGN1cnJlbnRQbGF5ZXJJbmRleCArIDEpICUgbnVtUGxheWVycztcclxuXHJcbiAgd2hpbGUgKG5leHRJbmRleCAhPT0gY3VycmVudFBsYXllckluZGV4KSB7XHJcbiAgICBjb25zdCBwbGF5ZXIgPSBkZWFsdENhcmRzW25leHRJbmRleF07XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBub3QgZm9sZGVkIGFuZCB0aGVpciBiZXQgaXMgbm90IGVxdWFsIHRvIHRoZSBoaWdoZXN0IGJldFxyXG4gICAgaWYgKCFwbGF5ZXIuZm9sZGVkICYmIChwbGF5ZXIuYmV0IHx8IDApIDwgaGlnaGVzdEJldCkge1xyXG4gICAgICByZXR1cm4gbmV4dEluZGV4OyAvLyBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBuZXh0IHBsYXllciB0byBhY3RcclxuICAgIH1cclxuXHJcbiAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHBsYXllclxyXG4gICAgbmV4dEluZGV4ID0gKG5leHRJbmRleCArIDEpICUgbnVtUGxheWVycztcclxuICB9XHJcblxyXG4gIC8vIElmIG5vIGVsaWdpYmxlIHBsYXllciBmb3VuZCwgcmV0dXJuIC0xIHRvIGluZGljYXRlIHRoZSByb3VuZCBpcyBjb21wbGV0ZVxyXG4gIHJldHVybiAtMTtcclxufTtcclxuIl0sIm5hbWVzIjpbIkJJR19CTElORCIsImdhbWVTdGFydGVyIiwicG9zaXRpb25zIiwiZGVhbGVyIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwiZHNiIiwicGxheWVyIiwiYW1vdW50IiwiZGVhbHRDYXJkcyIsInJlbWFpbmluZ0RlY2siLCJkZWFsQ2FyZHMiLCJjb25zb2xlIiwibG9nIiwiZGF0YSIsImFjdGlvbnMiLCJwcmVGbG9wIiwiZmxvcCIsInR1cm4iLCJyaXZlciIsImNvbW11bml0eV9jYXJkcyIsInJvdW5kIiwiZGVjayIsImNhcmRzVG9EcmF3IiwiY2FyZHMiLCJkcmF3bkNhcmRzIiwic2xpY2UiLCJ1cGRhdGVDYXJkcyIsInN0YXRlIiwicGxheWVySW5kZXgiLCJhY3Rpb24iLCJuZXdTdGF0ZSIsInB1c2giLCJ1bmRlZmluZWQiLCJuZXh0X2FjdGlvbnMiLCJjdXJyZW50UGxheWVySW5kZXgiLCJyb3VuZEFjdGlvbnMiLCJjdXJyZW50QmV0IiwibWF4IiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJtYXAiLCJwbGF5ZXJCZXQiLCJyZWR1Y2UiLCJzdW0iLCJhdmFpbGFibGVBY3Rpb25zIiwic2hvdWxkX2NvbnRpbnVlX3JvdW5kIiwiY3VycmVudFJvdW5kIiwiYWxsUGxheWVyc0FjdGVkIiwiZXZlcnkiLCJzb21lIiwicGxheWVyQmV0VG90YWxzIiwiZm9yRWFjaCIsInVuaXF1ZUJldFRvdGFscyIsIlNldCIsIk9iamVjdCIsInZhbHVlcyIsInNpemUiLCJnZXROZXh0UGxheWVySW5kZXgiLCJyb3VuZHMiLCJjdXJyZW50Um91bmRJbmRleCIsImluZGV4T2YiLCJmb2xkZWRQbGF5ZXJzIiwiaSIsImFkZCIsInBsYXllcnMiLCJuZXh0UGxheWVySW5kZXgiLCJoYXMiLCJzdWl0cyIsInN1aXQiLCJ2YWx1ZSIsInNodWZmbGVkRGVjayIsInNvcnQiLCJzdGFydGluZ1Bvc2l0aW9uIiwicG9zaXRpb24iLCJwbGF5ZXJDYXJkcyIsInBvcCIsImRlYWx0Iiwiam9pbiIsIm5leHRfcGxheWVyIiwibnVtUGxheWVycyIsImhpZ2hlc3RCZXQiLCJiZXQiLCJuZXh0SW5kZXgiLCJmb2xkZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/gameUtils.ts\n"));

/***/ })

});