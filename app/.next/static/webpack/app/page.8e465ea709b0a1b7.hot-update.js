"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/gameUtils.ts":
/*!********************************!*\
  !*** ./src/utils/gameUtils.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BIG_BLIND: () => (/* binding */ BIG_BLIND),\n/* harmony export */   community_cards: () => (/* binding */ community_cards),\n/* harmony export */   dealCards: () => (/* binding */ dealCards),\n/* harmony export */   gameStarter: () => (/* binding */ gameStarter),\n/* harmony export */   getNextPlayerIndex: () => (/* binding */ getNextPlayerIndex),\n/* harmony export */   next_actions: () => (/* binding */ next_actions),\n/* harmony export */   next_player: () => (/* binding */ next_player),\n/* harmony export */   should_continue_round: () => (/* binding */ should_continue_round),\n/* harmony export */   updateCards: () => (/* binding */ updateCards)\n/* harmony export */ });\nconst BIG_BLIND = 40;\nconst gameStarter = ()=>{\n    // 1. Position the players\n    const positions = [\n        1,\n        2,\n        3,\n        4,\n        5,\n        6\n    ];\n    // 2. Determine the dealer\n    const dealerIndex = Math.floor(Math.random() * positions.length);\n    // 3. Initialize the small blind and big blind\n    const dsb = {\n        dealer: {\n            player: positions[dealerIndex]\n        },\n        \"small blind\": {\n            player: positions[(dealerIndex + 1) % positions.length],\n            amount: BIG_BLIND / 2\n        },\n        \"big blind\": {\n            player: positions[(dealerIndex + 2) % positions.length],\n            amount: BIG_BLIND\n        }\n    };\n    // 4. Initialize a standard deck of 52 cards\n    const suits = [\n        \"hearts\",\n        \"diamonds\",\n        \"clubs\",\n        \"spades\"\n    ];\n    const values = [\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"10\",\n        \"J\",\n        \"Q\",\n        \"K\",\n        \"A\"\n    ];\n    let deck = suits.flatMap((suit)=>values.map((value)=>({\n                suit,\n                value\n            })));\n    // 5. Shuffle the deck\n    deck = deck.sort(()=>Math.random() - 0.5);\n    // 6. Deal cards (2 cards per player)\n    const dealtCards = {};\n    const playersCount = positions.length;\n    for(let i = 0; i < playersCount; i++){\n        dealtCards[positions[i]] = deck.slice(i * 2, i * 2 + 2);\n    }\n    // 7. Update remaining deck by removing dealt cards\n    const remainingDeck = deck.slice(playersCount * 2);\n    // 8. Return game state with initial setup\n    return {\n        data: dealtCards,\n        dsb,\n        remainingDeck,\n        actions: {\n            preFlop: [],\n            flop: [],\n            turn: [],\n            river: []\n        }\n    };\n};\nconst community_cards = (round, deck)=>{\n    let cardsToDraw;\n    switch(round){\n        case \"flop\":\n            cardsToDraw = 3; // Draw 3 cards for the flop\n            break;\n        case \"turn\":\n        case \"river\":\n            cardsToDraw = 1; // Draw 1 card for turn and river\n            break;\n        default:\n            return {\n                cards: [],\n                remainingDeck: deck\n            }; // For preFlop or invalid rounds, return an empty set of cards\n    }\n    // Draw the specified number of cards from the deck\n    const drawnCards = deck.slice(0, cardsToDraw);\n    const remainingDeck = deck.slice(cardsToDraw);\n    return {\n        cards: drawnCards,\n        remainingDeck\n    };\n};\nconst updateCards = (state, round, playerIndex, action, amount)=>{\n    // Create a copy of the state to ensure immutability\n    const newState = {\n        ...state,\n        actions: {\n            ...state.actions\n        }\n    };\n    // Ensure the actions array for the specified round exists\n    if (!newState.actions[round]) {\n        newState.actions[round] = [];\n    }\n    // Add a new action entry to the round's actions array\n    newState.actions[round].push({\n        player: newState.data[playerIndex].player,\n        action,\n        ...amount !== undefined && {\n            amount\n        }\n    });\n    return newState;\n};\nconst next_actions = (actions, round, currentPlayerIndex)=>{\n    console.log(\"actions in next_actions\", actions);\n    // Extract actions taken in the specified round\n    const roundActions = actions[round] || [];\n    // Determine the highest bet made in the current round\n    const currentBet = Math.max(0, ...roundActions.filter((action)=>[\n            \"bet\",\n            \"raise\",\n            \"call\"\n        ].includes(action.action)).map((action)=>action.amount || 0));\n    // Calculate the total amount the current player has contributed in this round\n    const playerBet = roundActions.filter((action)=>action.playerIndex === currentPlayerIndex).reduce((sum, action)=>sum + (action.amount || 0), 0);\n    // Initialize possible actions for the player\n    const availableActions = [\n        \"fold\"\n    ];\n    // Determine available actions based on the current betting state\n    if (currentBet === 0) {\n        // No existing bet in the round: player can \"check\" or \"bet\"\n        availableActions.push(\"check\", \"bet\");\n    } else {\n        // There's an existing bet in the round\n        if (playerBet < currentBet) {\n            availableActions.push(\"call\"); // Player can call to match the current bet\n        }\n        if (playerBet === currentBet) {\n            availableActions.push(\"check\"); // Player can check if they’ve matched the bet\n        }\n        if (playerBet < currentBet) {\n            availableActions.push(\"raise\"); // Player can raise if they have chips to increase the current bet\n        }\n    }\n    // Add \"all-in\" as an option\n    availableActions.push(\"all-in\");\n    return availableActions;\n};\nconst should_continue_round = (actions, data, currentRound)=>{\n    // Get the list of actions for the current round\n    const roundActions = actions[currentRound];\n    // Check if every player in `data` has made an action in the current round\n    const allPlayersActed = data.every((player)=>roundActions.some((action)=>action.player === player.player));\n    // Calculate the total bet amount for each player in the current round\n    const playerBetTotals = {};\n    roundActions.forEach((action)=>{\n        if ([\n            \"bet\",\n            \"raise\",\n            \"call\"\n        ].includes(action.action) && action.amount !== undefined) {\n            playerBetTotals[action.player] = (playerBetTotals[action.player] || 0) + action.amount;\n        }\n    });\n    // Get all unique bet totals from players who acted in the round\n    const uniqueBetTotals = new Set(Object.values(playerBetTotals));\n    // All players must act, and their total bet amounts must be equal\n    return allPlayersActed && uniqueBetTotals.size === 1;\n};\nconst getNextPlayerIndex = (playerIndex, data, currentRound)=>{\n    const rounds = [\n        \"preFlop\",\n        \"flop\",\n        \"turn\",\n        \"river\"\n    ];\n    const currentRoundIndex = rounds.indexOf(currentRound);\n    // Step 1: Identify all players who have folded in any round up to the current round\n    const foldedPlayers = new Set();\n    for(let i = 0; i <= currentRoundIndex; i++){\n        const round = rounds[i];\n        if (data.actions[round]) {\n            data.actions[round].forEach((action)=>{\n                if (action.action === \"fold\") {\n                    foldedPlayers.add(action.player);\n                }\n            });\n        }\n    }\n    // Step 2: Find the next active player index\n    const players = data.players; // Assuming `data.players` is an array of player objects or IDs\n    let nextPlayerIndex = playerIndex;\n    do {\n        nextPlayerIndex = (nextPlayerIndex + 1) % players.length; // Move to the next player in a circular manner\n    }while (foldedPlayers.has(players[nextPlayerIndex]) && nextPlayerIndex !== playerIndex);\n    // If we looped back to the original playerIndex without finding an active player, return -1 (or handle as needed)\n    if (nextPlayerIndex === playerIndex && foldedPlayers.has(players[nextPlayerIndex])) {\n        return -1; // No eligible player found\n    }\n    return nextPlayerIndex;\n};\n// Helper function to generate dealt cards for each player\nconst dealCards = function() {\n    let players = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6, dealer = arguments.length > 1 ? arguments[1] : void 0;\n    const suits = [\n        \"♠\",\n        \"♥\",\n        \"♦\",\n        \"♣\"\n    ];\n    const values = [\n        \"A\",\n        \"K\",\n        \"Q\",\n        \"J\",\n        \"10\",\n        \"9\",\n        \"8\",\n        \"7\",\n        \"6\",\n        \"5\",\n        \"4\",\n        \"3\",\n        \"2\"\n    ];\n    // Generate a full deck of cards\n    const deck = [];\n    for (const suit of suits){\n        for (const value of values){\n            deck.push(\"\".concat(value).concat(suit));\n        }\n    }\n    // Shuffle the deck\n    const shuffledDeck = deck.sort(()=>Math.random() - 0.5);\n    // Deal two cards to each player, starting from the player after the dealer\n    const dealtCards = [];\n    const startingPosition = (dealer + 1) % players;\n    for(let i = 0; i < players; i++){\n        const position = (startingPosition + i) % players;\n        const playerCards = [\n            shuffledDeck.pop(),\n            shuffledDeck.pop()\n        ]; // Deal two cards per player\n        const playerHand = playerCards.join(\" \"); // Format as \"Ac Kh\"\n        dealtCards.push({\n            player: position + 1,\n            dealt: playerHand\n        });\n    }\n    // After dealing cards, the remaining deck is what's left in shuffledDeck\n    const remainingDeck = [\n        ...shuffledDeck\n    ];\n    return {\n        dealtCards,\n        remainingDeck\n    };\n};\n// Helper function to tell the next player to act\nconst next_player = (state, currentPlayerIndex)=>{\n    const { dealtCards } = state; // Access the list of players from the state\n    const numPlayers = dealtCards.length;\n    // Find the highest bet made in the current stage\n    const highestBet = Math.max(...dealtCards.map((player)=>player.bet || 0) // Assuming `bet` property stores each player’s current bet amount\n    );\n    // Start from the next player and loop until finding an eligible player\n    let nextIndex = (currentPlayerIndex + 1) % numPlayers;\n    while(nextIndex !== currentPlayerIndex){\n        const player = dealtCards[nextIndex];\n        // Check if player has not folded and their bet is not equal to the highest bet\n        if (!player.folded && (player.bet || 0) < highestBet) {\n            return nextIndex; // Return the index of the next player to act\n        }\n        // Move to the next player\n        nextIndex = (nextIndex + 1) % numPlayers;\n    }\n    // If no eligible player found, return -1 to indicate the round is complete\n    return -1;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9nYW1lVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRU8sTUFBTUEsWUFBWSxHQUFHO0FBQ3JCLE1BQU1DLGNBQWM7SUFDekIsMEJBQTBCO0lBQzFCLE1BQU1DLFlBQVk7UUFBQztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7S0FBRTtJQUVwQywwQkFBMEI7SUFDMUIsTUFBTUMsY0FBY0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUtKLFVBQVVLLE1BQU07SUFFL0QsOENBQThDO0lBQzlDLE1BQU1DLE1BQU07UUFDVkMsUUFBUTtZQUFFQyxRQUFRUixTQUFTLENBQUNDLFlBQVk7UUFBQztRQUN6QyxlQUFlO1lBQ2JPLFFBQVFSLFNBQVMsQ0FBQyxDQUFDQyxjQUFjLEtBQUtELFVBQVVLLE1BQU0sQ0FBQztZQUN2REksUUFBUVgsWUFBWTtRQUN0QjtRQUNBLGFBQWE7WUFDWFUsUUFBUVIsU0FBUyxDQUFDLENBQUNDLGNBQWMsS0FBS0QsVUFBVUssTUFBTSxDQUFDO1lBQ3ZESSxRQUFRWDtRQUNWO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsTUFBTVksUUFBUTtRQUFDO1FBQVU7UUFBWTtRQUFTO0tBQVM7SUFDdkQsTUFBTUMsU0FBUztRQUNiO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDRCxJQUFJQyxPQUFPRixNQUFNRyxPQUFPLENBQUMsQ0FBQ0MsT0FBU0gsT0FBT0ksR0FBRyxDQUFDLENBQUNDLFFBQVc7Z0JBQUVGO2dCQUFNRTtZQUFNO0lBRXhFLHNCQUFzQjtJQUN0QkosT0FBT0EsS0FBS0ssSUFBSSxDQUFDLElBQU1mLEtBQUtFLE1BQU0sS0FBSztJQUV2QyxxQ0FBcUM7SUFDckMsTUFBTWMsYUFBZ0UsQ0FBQztJQUN2RSxNQUFNQyxlQUFlbkIsVUFBVUssTUFBTTtJQUNyQyxJQUFLLElBQUll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QVU7UUFFcEMsK0VBQStFO1FBQy9FLElBQUksQ0FBQy9FLE9BQU9nRixNQUFNLElBQUksQ0FBQ2hGLE9BQU84RSxHQUFHLElBQUksS0FBS0QsWUFBWTtZQUNwRCxPQUFPRSxXQUFXLDZDQUE2QztRQUNqRTtRQUVBLDBCQUEwQjtRQUMxQkEsWUFBWSxDQUFDQSxZQUFZLEtBQUtIO0lBQ2hDO0lBRUEsMkVBQTJFO0lBQzNFLE9BQU8sQ0FBQztBQUNWLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvZ2FtZVV0aWxzLnRzPzViOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aW9uLCBSb3VuZCB9IGZyb20gXCJAL2FwcC9wYWdlXCI7XHJcblxyXG5leHBvcnQgY29uc3QgQklHX0JMSU5EID0gNDA7XHJcbmV4cG9ydCBjb25zdCBnYW1lU3RhcnRlciA9ICgpID0+IHtcclxuICAvLyAxLiBQb3NpdGlvbiB0aGUgcGxheWVyc1xyXG4gIGNvbnN0IHBvc2l0aW9ucyA9IFsxLCAyLCAzLCA0LCA1LCA2XTtcclxuXHJcbiAgLy8gMi4gRGV0ZXJtaW5lIHRoZSBkZWFsZXJcclxuICBjb25zdCBkZWFsZXJJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvc2l0aW9ucy5sZW5ndGgpO1xyXG5cclxuICAvLyAzLiBJbml0aWFsaXplIHRoZSBzbWFsbCBibGluZCBhbmQgYmlnIGJsaW5kXHJcbiAgY29uc3QgZHNiID0ge1xyXG4gICAgZGVhbGVyOiB7IHBsYXllcjogcG9zaXRpb25zW2RlYWxlckluZGV4XSB9LFxyXG4gICAgXCJzbWFsbCBibGluZFwiOiB7XHJcbiAgICAgIHBsYXllcjogcG9zaXRpb25zWyhkZWFsZXJJbmRleCArIDEpICUgcG9zaXRpb25zLmxlbmd0aF0sXHJcbiAgICAgIGFtb3VudDogQklHX0JMSU5EIC8gMixcclxuICAgIH0sXHJcbiAgICBcImJpZyBibGluZFwiOiB7XHJcbiAgICAgIHBsYXllcjogcG9zaXRpb25zWyhkZWFsZXJJbmRleCArIDIpICUgcG9zaXRpb25zLmxlbmd0aF0sXHJcbiAgICAgIGFtb3VudDogQklHX0JMSU5ELFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICAvLyA0LiBJbml0aWFsaXplIGEgc3RhbmRhcmQgZGVjayBvZiA1MiBjYXJkc1xyXG4gIGNvbnN0IHN1aXRzID0gW1wiaGVhcnRzXCIsIFwiZGlhbW9uZHNcIiwgXCJjbHVic1wiLCBcInNwYWRlc1wiXTtcclxuICBjb25zdCB2YWx1ZXMgPSBbXHJcbiAgICBcIjJcIixcclxuICAgIFwiM1wiLFxyXG4gICAgXCI0XCIsXHJcbiAgICBcIjVcIixcclxuICAgIFwiNlwiLFxyXG4gICAgXCI3XCIsXHJcbiAgICBcIjhcIixcclxuICAgIFwiOVwiLFxyXG4gICAgXCIxMFwiLFxyXG4gICAgXCJKXCIsXHJcbiAgICBcIlFcIixcclxuICAgIFwiS1wiLFxyXG4gICAgXCJBXCIsXHJcbiAgXTtcclxuICBsZXQgZGVjayA9IHN1aXRzLmZsYXRNYXAoKHN1aXQpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiAoeyBzdWl0LCB2YWx1ZSB9KSkpO1xyXG5cclxuICAvLyA1LiBTaHVmZmxlIHRoZSBkZWNrXHJcbiAgZGVjayA9IGRlY2suc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcclxuXHJcbiAgLy8gNi4gRGVhbCBjYXJkcyAoMiBjYXJkcyBwZXIgcGxheWVyKVxyXG4gIGNvbnN0IGRlYWx0Q2FyZHM6IFJlY29yZDxudW1iZXIsIHsgc3VpdDogc3RyaW5nOyB2YWx1ZTogc3RyaW5nIH1bXT4gPSB7fTtcclxuICBjb25zdCBwbGF5ZXJzQ291bnQgPSBwb3NpdGlvbnMubGVuZ3RoO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGxheWVyc0NvdW50OyBpKyspIHtcclxuICAgIGRlYWx0Q2FyZHNbcG9zaXRpb25zW2ldXSA9IGRlY2suc2xpY2UoaSAqIDIsIGkgKiAyICsgMik7XHJcbiAgfVxyXG5cclxuICAvLyA3LiBVcGRhdGUgcmVtYWluaW5nIGRlY2sgYnkgcmVtb3ZpbmcgZGVhbHQgY2FyZHNcclxuICBjb25zdCByZW1haW5pbmdEZWNrID0gZGVjay5zbGljZShwbGF5ZXJzQ291bnQgKiAyKTtcclxuXHJcbiAgLy8gOC4gUmV0dXJuIGdhbWUgc3RhdGUgd2l0aCBpbml0aWFsIHNldHVwXHJcbiAgcmV0dXJuIHtcclxuICAgIGRhdGE6IGRlYWx0Q2FyZHMsXHJcbiAgICBkc2IsXHJcbiAgICByZW1haW5pbmdEZWNrLFxyXG4gICAgYWN0aW9uczoge1xyXG4gICAgICBwcmVGbG9wOiBbXSxcclxuICAgICAgZmxvcDogW10sXHJcbiAgICAgIHR1cm46IFtdLFxyXG4gICAgICByaXZlcjogW10sXHJcbiAgICB9LFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY29tbXVuaXR5X2NhcmRzID0gKHJvdW5kOiBSb3VuZCwgZGVjazogc3RyaW5nW10pID0+IHtcclxuICBsZXQgY2FyZHNUb0RyYXc7XHJcblxyXG4gIHN3aXRjaCAocm91bmQpIHtcclxuICAgIGNhc2UgXCJmbG9wXCI6XHJcbiAgICAgIGNhcmRzVG9EcmF3ID0gMzsgLy8gRHJhdyAzIGNhcmRzIGZvciB0aGUgZmxvcFxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJ0dXJuXCI6XHJcbiAgICBjYXNlIFwicml2ZXJcIjpcclxuICAgICAgY2FyZHNUb0RyYXcgPSAxOyAvLyBEcmF3IDEgY2FyZCBmb3IgdHVybiBhbmQgcml2ZXJcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4geyBjYXJkczogW10sIHJlbWFpbmluZ0RlY2s6IGRlY2sgfTsgLy8gRm9yIHByZUZsb3Agb3IgaW52YWxpZCByb3VuZHMsIHJldHVybiBhbiBlbXB0eSBzZXQgb2YgY2FyZHNcclxuICB9XHJcblxyXG4gIC8vIERyYXcgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY2FyZHMgZnJvbSB0aGUgZGVja1xyXG4gIGNvbnN0IGRyYXduQ2FyZHMgPSBkZWNrLnNsaWNlKDAsIGNhcmRzVG9EcmF3KTtcclxuICBjb25zdCByZW1haW5pbmdEZWNrID0gZGVjay5zbGljZShjYXJkc1RvRHJhdyk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBjYXJkczogZHJhd25DYXJkcyxcclxuICAgIHJlbWFpbmluZ0RlY2ssXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVDYXJkcyA9IChcclxuICBzdGF0ZTogYW55LFxyXG4gIHJvdW5kOiBzdHJpbmcsXHJcbiAgcGxheWVySW5kZXg6IG51bWJlcixcclxuICBhY3Rpb246IHN0cmluZyxcclxuICBhbW91bnQ/OiBudW1iZXJcclxuKSA9PiB7XHJcbiAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgc3RhdGUgdG8gZW5zdXJlIGltbXV0YWJpbGl0eVxyXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICBhY3Rpb25zOiB7IC4uLnN0YXRlLmFjdGlvbnMgfSxcclxuICB9O1xyXG5cclxuICAvLyBFbnN1cmUgdGhlIGFjdGlvbnMgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgcm91bmQgZXhpc3RzXHJcbiAgaWYgKCFuZXdTdGF0ZS5hY3Rpb25zW3JvdW5kXSkge1xyXG4gICAgbmV3U3RhdGUuYWN0aW9uc1tyb3VuZF0gPSBbXTtcclxuICB9XHJcblxyXG4gIC8vIEFkZCBhIG5ldyBhY3Rpb24gZW50cnkgdG8gdGhlIHJvdW5kJ3MgYWN0aW9ucyBhcnJheVxyXG4gIG5ld1N0YXRlLmFjdGlvbnNbcm91bmRdLnB1c2goe1xyXG4gICAgcGxheWVyOiBuZXdTdGF0ZS5kYXRhW3BsYXllckluZGV4XS5wbGF5ZXIsXHJcbiAgICBhY3Rpb24sXHJcbiAgICAuLi4oYW1vdW50ICE9PSB1bmRlZmluZWQgJiYgeyBhbW91bnQgfSksIC8vIENvbmRpdGlvbmFsbHkgYWRkIGFtb3VudCBpZiBwcm92aWRlZFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn07XHJcbmV4cG9ydCBjb25zdCBuZXh0X2FjdGlvbnMgPSAoXHJcbiAgYWN0aW9uczoge1xyXG4gICAgW2tleSBpbiBSb3VuZF06IEFycmF5PHtcclxuICAgICAgcGxheWVySW5kZXg6IG51bWJlcjtcclxuICAgICAgYWN0aW9uOiBzdHJpbmc7XHJcbiAgICAgIGFtb3VudD86IG51bWJlcjtcclxuICAgIH0+O1xyXG4gIH0sXHJcbiAgcm91bmQ6IFJvdW5kLFxyXG4gIGN1cnJlbnRQbGF5ZXJJbmRleDogbnVtYmVyXHJcbik6IEFjdGlvbltdID0+IHtcclxuICBjb25zb2xlLmxvZyhcImFjdGlvbnMgaW4gbmV4dF9hY3Rpb25zXCIsIGFjdGlvbnMpO1xyXG4gIC8vIEV4dHJhY3QgYWN0aW9ucyB0YWtlbiBpbiB0aGUgc3BlY2lmaWVkIHJvdW5kXHJcbiAgY29uc3Qgcm91bmRBY3Rpb25zID0gYWN0aW9uc1tyb3VuZF0gfHwgW107XHJcblxyXG4gIC8vIERldGVybWluZSB0aGUgaGlnaGVzdCBiZXQgbWFkZSBpbiB0aGUgY3VycmVudCByb3VuZFxyXG4gIGNvbnN0IGN1cnJlbnRCZXQgPSBNYXRoLm1heChcclxuICAgIDAsXHJcbiAgICAuLi5yb3VuZEFjdGlvbnNcclxuICAgICAgLmZpbHRlcigoYWN0aW9uKSA9PiBbXCJiZXRcIiwgXCJyYWlzZVwiLCBcImNhbGxcIl0uaW5jbHVkZXMoYWN0aW9uLmFjdGlvbikpXHJcbiAgICAgIC5tYXAoKGFjdGlvbikgPT4gYWN0aW9uLmFtb3VudCB8fCAwKVxyXG4gICk7XHJcblxyXG4gIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgYW1vdW50IHRoZSBjdXJyZW50IHBsYXllciBoYXMgY29udHJpYnV0ZWQgaW4gdGhpcyByb3VuZFxyXG4gIGNvbnN0IHBsYXllckJldCA9IHJvdW5kQWN0aW9uc1xyXG4gICAgLmZpbHRlcigoYWN0aW9uKSA9PiBhY3Rpb24ucGxheWVySW5kZXggPT09IGN1cnJlbnRQbGF5ZXJJbmRleClcclxuICAgIC5yZWR1Y2UoKHN1bSwgYWN0aW9uKSA9PiBzdW0gKyAoYWN0aW9uLmFtb3VudCB8fCAwKSwgMCk7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcG9zc2libGUgYWN0aW9ucyBmb3IgdGhlIHBsYXllclxyXG4gIGNvbnN0IGF2YWlsYWJsZUFjdGlvbnM6IEFjdGlvbltdID0gW1wiZm9sZFwiXTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIGF2YWlsYWJsZSBhY3Rpb25zIGJhc2VkIG9uIHRoZSBjdXJyZW50IGJldHRpbmcgc3RhdGVcclxuICBpZiAoY3VycmVudEJldCA9PT0gMCkge1xyXG4gICAgLy8gTm8gZXhpc3RpbmcgYmV0IGluIHRoZSByb3VuZDogcGxheWVyIGNhbiBcImNoZWNrXCIgb3IgXCJiZXRcIlxyXG4gICAgYXZhaWxhYmxlQWN0aW9ucy5wdXNoKFwiY2hlY2tcIiwgXCJiZXRcIik7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFRoZXJlJ3MgYW4gZXhpc3RpbmcgYmV0IGluIHRoZSByb3VuZFxyXG4gICAgaWYgKHBsYXllckJldCA8IGN1cnJlbnRCZXQpIHtcclxuICAgICAgYXZhaWxhYmxlQWN0aW9ucy5wdXNoKFwiY2FsbFwiKTsgLy8gUGxheWVyIGNhbiBjYWxsIHRvIG1hdGNoIHRoZSBjdXJyZW50IGJldFxyXG4gICAgfVxyXG4gICAgaWYgKHBsYXllckJldCA9PT0gY3VycmVudEJldCkge1xyXG4gICAgICBhdmFpbGFibGVBY3Rpb25zLnB1c2goXCJjaGVja1wiKTsgLy8gUGxheWVyIGNhbiBjaGVjayBpZiB0aGV54oCZdmUgbWF0Y2hlZCB0aGUgYmV0XHJcbiAgICB9XHJcbiAgICBpZiAocGxheWVyQmV0IDwgY3VycmVudEJldCkge1xyXG4gICAgICBhdmFpbGFibGVBY3Rpb25zLnB1c2goXCJyYWlzZVwiKTsgLy8gUGxheWVyIGNhbiByYWlzZSBpZiB0aGV5IGhhdmUgY2hpcHMgdG8gaW5jcmVhc2UgdGhlIGN1cnJlbnQgYmV0XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgXCJhbGwtaW5cIiBhcyBhbiBvcHRpb25cclxuICBhdmFpbGFibGVBY3Rpb25zLnB1c2goXCJhbGwtaW5cIik7XHJcblxyXG4gIHJldHVybiBhdmFpbGFibGVBY3Rpb25zO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNob3VsZF9jb250aW51ZV9yb3VuZCA9IChcclxuICBhY3Rpb25zOiB7XHJcbiAgICBba2V5IGluIFJvdW5kXTogQXJyYXk8eyBwbGF5ZXI6IHN0cmluZzsgYWN0aW9uOiBzdHJpbmc7IGFtb3VudD86IG51bWJlciB9PjtcclxuICB9LFxyXG4gIGRhdGE6IGFueVtdLFxyXG4gIGN1cnJlbnRSb3VuZDogUm91bmRcclxuKSA9PiB7XHJcbiAgLy8gR2V0IHRoZSBsaXN0IG9mIGFjdGlvbnMgZm9yIHRoZSBjdXJyZW50IHJvdW5kXHJcbiAgY29uc3Qgcm91bmRBY3Rpb25zID0gYWN0aW9uc1tjdXJyZW50Um91bmRdO1xyXG5cclxuICAvLyBDaGVjayBpZiBldmVyeSBwbGF5ZXIgaW4gYGRhdGFgIGhhcyBtYWRlIGFuIGFjdGlvbiBpbiB0aGUgY3VycmVudCByb3VuZFxyXG4gIGNvbnN0IGFsbFBsYXllcnNBY3RlZCA9IGRhdGEuZXZlcnkoKHBsYXllcikgPT5cclxuICAgIHJvdW5kQWN0aW9ucy5zb21lKChhY3Rpb24pID0+IGFjdGlvbi5wbGF5ZXIgPT09IHBsYXllci5wbGF5ZXIpXHJcbiAgKTtcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBiZXQgYW1vdW50IGZvciBlYWNoIHBsYXllciBpbiB0aGUgY3VycmVudCByb3VuZFxyXG4gIGNvbnN0IHBsYXllckJldFRvdGFsczogeyBbcGxheWVyOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xyXG5cclxuICByb3VuZEFjdGlvbnMuZm9yRWFjaCgoYWN0aW9uKSA9PiB7XHJcbiAgICBpZiAoXHJcbiAgICAgIFtcImJldFwiLCBcInJhaXNlXCIsIFwiY2FsbFwiXS5pbmNsdWRlcyhhY3Rpb24uYWN0aW9uKSAmJlxyXG4gICAgICBhY3Rpb24uYW1vdW50ICE9PSB1bmRlZmluZWRcclxuICAgICkge1xyXG4gICAgICBwbGF5ZXJCZXRUb3RhbHNbYWN0aW9uLnBsYXllcl0gPVxyXG4gICAgICAgIChwbGF5ZXJCZXRUb3RhbHNbYWN0aW9uLnBsYXllcl0gfHwgMCkgKyBhY3Rpb24uYW1vdW50O1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBHZXQgYWxsIHVuaXF1ZSBiZXQgdG90YWxzIGZyb20gcGxheWVycyB3aG8gYWN0ZWQgaW4gdGhlIHJvdW5kXHJcbiAgY29uc3QgdW5pcXVlQmV0VG90YWxzID0gbmV3IFNldChPYmplY3QudmFsdWVzKHBsYXllckJldFRvdGFscykpO1xyXG5cclxuICAvLyBBbGwgcGxheWVycyBtdXN0IGFjdCwgYW5kIHRoZWlyIHRvdGFsIGJldCBhbW91bnRzIG11c3QgYmUgZXF1YWxcclxuICByZXR1cm4gYWxsUGxheWVyc0FjdGVkICYmIHVuaXF1ZUJldFRvdGFscy5zaXplID09PSAxO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldE5leHRQbGF5ZXJJbmRleCA9IChcclxuICBwbGF5ZXJJbmRleDogbnVtYmVyLFxyXG4gIGRhdGE6IGFueSxcclxuICBjdXJyZW50Um91bmQ6IFJvdW5kXHJcbikgPT4ge1xyXG4gIGNvbnN0IHJvdW5kcyA9IFtcInByZUZsb3BcIiwgXCJmbG9wXCIsIFwidHVyblwiLCBcInJpdmVyXCJdO1xyXG4gIGNvbnN0IGN1cnJlbnRSb3VuZEluZGV4ID0gcm91bmRzLmluZGV4T2YoY3VycmVudFJvdW5kKTtcclxuXHJcbiAgLy8gU3RlcCAxOiBJZGVudGlmeSBhbGwgcGxheWVycyB3aG8gaGF2ZSBmb2xkZWQgaW4gYW55IHJvdW5kIHVwIHRvIHRoZSBjdXJyZW50IHJvdW5kXHJcbiAgY29uc3QgZm9sZGVkUGxheWVycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8PSBjdXJyZW50Um91bmRJbmRleDsgaSsrKSB7XHJcbiAgICBjb25zdCByb3VuZCA9IHJvdW5kc1tpXTtcclxuICAgIGlmIChkYXRhLmFjdGlvbnNbcm91bmRdKSB7XHJcbiAgICAgIGRhdGEuYWN0aW9uc1tyb3VuZF0uZm9yRWFjaChcclxuICAgICAgICAoYWN0aW9uOiB7IHBsYXllcjogc3RyaW5nOyBhY3Rpb246IHN0cmluZyB9KSA9PiB7XHJcbiAgICAgICAgICBpZiAoYWN0aW9uLmFjdGlvbiA9PT0gXCJmb2xkXCIpIHtcclxuICAgICAgICAgICAgZm9sZGVkUGxheWVycy5hZGQoYWN0aW9uLnBsYXllcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU3RlcCAyOiBGaW5kIHRoZSBuZXh0IGFjdGl2ZSBwbGF5ZXIgaW5kZXhcclxuICBjb25zdCBwbGF5ZXJzID0gZGF0YS5wbGF5ZXJzOyAvLyBBc3N1bWluZyBgZGF0YS5wbGF5ZXJzYCBpcyBhbiBhcnJheSBvZiBwbGF5ZXIgb2JqZWN0cyBvciBJRHNcclxuICBsZXQgbmV4dFBsYXllckluZGV4ID0gcGxheWVySW5kZXg7XHJcblxyXG4gIGRvIHtcclxuICAgIG5leHRQbGF5ZXJJbmRleCA9IChuZXh0UGxheWVySW5kZXggKyAxKSAlIHBsYXllcnMubGVuZ3RoOyAvLyBNb3ZlIHRvIHRoZSBuZXh0IHBsYXllciBpbiBhIGNpcmN1bGFyIG1hbm5lclxyXG4gIH0gd2hpbGUgKFxyXG4gICAgZm9sZGVkUGxheWVycy5oYXMocGxheWVyc1tuZXh0UGxheWVySW5kZXhdKSAmJlxyXG4gICAgbmV4dFBsYXllckluZGV4ICE9PSBwbGF5ZXJJbmRleFxyXG4gICk7XHJcblxyXG4gIC8vIElmIHdlIGxvb3BlZCBiYWNrIHRvIHRoZSBvcmlnaW5hbCBwbGF5ZXJJbmRleCB3aXRob3V0IGZpbmRpbmcgYW4gYWN0aXZlIHBsYXllciwgcmV0dXJuIC0xIChvciBoYW5kbGUgYXMgbmVlZGVkKVxyXG4gIGlmIChcclxuICAgIG5leHRQbGF5ZXJJbmRleCA9PT0gcGxheWVySW5kZXggJiZcclxuICAgIGZvbGRlZFBsYXllcnMuaGFzKHBsYXllcnNbbmV4dFBsYXllckluZGV4XSlcclxuICApIHtcclxuICAgIHJldHVybiAtMTsgLy8gTm8gZWxpZ2libGUgcGxheWVyIGZvdW5kXHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV4dFBsYXllckluZGV4O1xyXG59O1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGRlYWx0IGNhcmRzIGZvciBlYWNoIHBsYXllclxyXG5leHBvcnQgY29uc3QgZGVhbENhcmRzID0gKHBsYXllcnMgPSA2LCBkZWFsZXI6IG51bWJlcikgPT4ge1xyXG4gIGNvbnN0IHN1aXRzID0gW1wi4pmgXCIsIFwi4pmlXCIsIFwi4pmmXCIsIFwi4pmjXCJdO1xyXG4gIGNvbnN0IHZhbHVlcyA9IFtcclxuICAgIFwiQVwiLFxyXG4gICAgXCJLXCIsXHJcbiAgICBcIlFcIixcclxuICAgIFwiSlwiLFxyXG4gICAgXCIxMFwiLFxyXG4gICAgXCI5XCIsXHJcbiAgICBcIjhcIixcclxuICAgIFwiN1wiLFxyXG4gICAgXCI2XCIsXHJcbiAgICBcIjVcIixcclxuICAgIFwiNFwiLFxyXG4gICAgXCIzXCIsXHJcbiAgICBcIjJcIixcclxuICBdO1xyXG5cclxuICAvLyBHZW5lcmF0ZSBhIGZ1bGwgZGVjayBvZiBjYXJkc1xyXG4gIGNvbnN0IGRlY2sgPSBbXTtcclxuICBmb3IgKGNvbnN0IHN1aXQgb2Ygc3VpdHMpIHtcclxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XHJcbiAgICAgIGRlY2sucHVzaChgJHt2YWx1ZX0ke3N1aXR9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTaHVmZmxlIHRoZSBkZWNrXHJcbiAgY29uc3Qgc2h1ZmZsZWREZWNrID0gZGVjay5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xyXG5cclxuICAvLyBEZWFsIHR3byBjYXJkcyB0byBlYWNoIHBsYXllciwgc3RhcnRpbmcgZnJvbSB0aGUgcGxheWVyIGFmdGVyIHRoZSBkZWFsZXJcclxuICBjb25zdCBkZWFsdENhcmRzID0gW107XHJcbiAgY29uc3Qgc3RhcnRpbmdQb3NpdGlvbiA9IChkZWFsZXIgKyAxKSAlIHBsYXllcnM7XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGxheWVyczsgaSsrKSB7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IChzdGFydGluZ1Bvc2l0aW9uICsgaSkgJSBwbGF5ZXJzO1xyXG4gICAgY29uc3QgcGxheWVyQ2FyZHMgPSBbc2h1ZmZsZWREZWNrLnBvcCgpLCBzaHVmZmxlZERlY2sucG9wKCldOyAvLyBEZWFsIHR3byBjYXJkcyBwZXIgcGxheWVyXHJcbiAgICBjb25zdCBwbGF5ZXJIYW5kID0gcGxheWVyQ2FyZHMuam9pbihcIiBcIik7IC8vIEZvcm1hdCBhcyBcIkFjIEtoXCJcclxuICAgIGRlYWx0Q2FyZHMucHVzaCh7XHJcbiAgICAgIHBsYXllcjogcG9zaXRpb24gKyAxLCAvLyBBc3N1bWluZyBwb3NpdGlvbnMgYXJlIDEtaW5kZXhlZCAoMSwgMiwgLi4uLCA2KVxyXG4gICAgICBkZWFsdDogcGxheWVySGFuZCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQWZ0ZXIgZGVhbGluZyBjYXJkcywgdGhlIHJlbWFpbmluZyBkZWNrIGlzIHdoYXQncyBsZWZ0IGluIHNodWZmbGVkRGVja1xyXG4gIGNvbnN0IHJlbWFpbmluZ0RlY2sgPSBbLi4uc2h1ZmZsZWREZWNrXTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGRlYWx0Q2FyZHMsXHJcbiAgICByZW1haW5pbmdEZWNrLFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gdGVsbCB0aGUgbmV4dCBwbGF5ZXIgdG8gYWN0XHJcbmV4cG9ydCBjb25zdCBuZXh0X3BsYXllciA9IChzdGF0ZTogYW55LCBjdXJyZW50UGxheWVySW5kZXg6IG51bWJlcikgPT4ge1xyXG4gIGNvbnN0IHsgZGVhbHRDYXJkcyB9ID0gc3RhdGU7IC8vIEFjY2VzcyB0aGUgbGlzdCBvZiBwbGF5ZXJzIGZyb20gdGhlIHN0YXRlXHJcbiAgY29uc3QgbnVtUGxheWVycyA9IGRlYWx0Q2FyZHMubGVuZ3RoO1xyXG5cclxuICAvLyBGaW5kIHRoZSBoaWdoZXN0IGJldCBtYWRlIGluIHRoZSBjdXJyZW50IHN0YWdlXHJcbiAgY29uc3QgaGlnaGVzdEJldCA9IE1hdGgubWF4KFxyXG4gICAgLi4uZGVhbHRDYXJkcy5tYXAoKHBsYXllcikgPT4gcGxheWVyLmJldCB8fCAwKSAvLyBBc3N1bWluZyBgYmV0YCBwcm9wZXJ0eSBzdG9yZXMgZWFjaCBwbGF5ZXLigJlzIGN1cnJlbnQgYmV0IGFtb3VudFxyXG4gICk7XHJcblxyXG4gIC8vIFN0YXJ0IGZyb20gdGhlIG5leHQgcGxheWVyIGFuZCBsb29wIHVudGlsIGZpbmRpbmcgYW4gZWxpZ2libGUgcGxheWVyXHJcbiAgbGV0IG5leHRJbmRleCA9IChjdXJyZW50UGxheWVySW5kZXggKyAxKSAlIG51bVBsYXllcnM7XHJcblxyXG4gIHdoaWxlIChuZXh0SW5kZXggIT09IGN1cnJlbnRQbGF5ZXJJbmRleCkge1xyXG4gICAgY29uc3QgcGxheWVyID0gZGVhbHRDYXJkc1tuZXh0SW5kZXhdO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgbm90IGZvbGRlZCBhbmQgdGhlaXIgYmV0IGlzIG5vdCBlcXVhbCB0byB0aGUgaGlnaGVzdCBiZXRcclxuICAgIGlmICghcGxheWVyLmZvbGRlZCAmJiAocGxheWVyLmJldCB8fCAwKSA8IGhpZ2hlc3RCZXQpIHtcclxuICAgICAgcmV0dXJuIG5leHRJbmRleDsgLy8gUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBwbGF5ZXIgdG8gYWN0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTW92ZSB0byB0aGUgbmV4dCBwbGF5ZXJcclxuICAgIG5leHRJbmRleCA9IChuZXh0SW5kZXggKyAxKSAlIG51bVBsYXllcnM7XHJcbiAgfVxyXG5cclxuICAvLyBJZiBubyBlbGlnaWJsZSBwbGF5ZXIgZm91bmQsIHJldHVybiAtMSB0byBpbmRpY2F0ZSB0aGUgcm91bmQgaXMgY29tcGxldGVcclxuICByZXR1cm4gLTE7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJCSUdfQkxJTkQiLCJnYW1lU3RhcnRlciIsInBvc2l0aW9ucyIsImRlYWxlckluZGV4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwiZHNiIiwiZGVhbGVyIiwicGxheWVyIiwiYW1vdW50Iiwic3VpdHMiLCJ2YWx1ZXMiLCJkZWNrIiwiZmxhdE1hcCIsInN1aXQiLCJtYXAiLCJ2YWx1ZSIsInNvcnQiLCJkZWFsdENhcmRzIiwicGxheWVyc0NvdW50IiwiaSIsInNsaWNlIiwicmVtYWluaW5nRGVjayIsImRhdGEiLCJhY3Rpb25zIiwicHJlRmxvcCIsImZsb3AiLCJ0dXJuIiwicml2ZXIiLCJjb21tdW5pdHlfY2FyZHMiLCJyb3VuZCIsImNhcmRzVG9EcmF3IiwiY2FyZHMiLCJkcmF3bkNhcmRzIiwidXBkYXRlQ2FyZHMiLCJzdGF0ZSIsInBsYXllckluZGV4IiwiYWN0aW9uIiwibmV3U3RhdGUiLCJwdXNoIiwidW5kZWZpbmVkIiwibmV4dF9hY3Rpb25zIiwiY3VycmVudFBsYXllckluZGV4IiwiY29uc29sZSIsImxvZyIsInJvdW5kQWN0aW9ucyIsImN1cnJlbnRCZXQiLCJtYXgiLCJmaWx0ZXIiLCJpbmNsdWRlcyIsInBsYXllckJldCIsInJlZHVjZSIsInN1bSIsImF2YWlsYWJsZUFjdGlvbnMiLCJzaG91bGRfY29udGludWVfcm91bmQiLCJjdXJyZW50Um91bmQiLCJhbGxQbGF5ZXJzQWN0ZWQiLCJldmVyeSIsInNvbWUiLCJwbGF5ZXJCZXRUb3RhbHMiLCJmb3JFYWNoIiwidW5pcXVlQmV0VG90YWxzIiwiU2V0IiwiT2JqZWN0Iiwic2l6ZSIsImdldE5leHRQbGF5ZXJJbmRleCIsInJvdW5kcyIsImN1cnJlbnRSb3VuZEluZGV4IiwiaW5kZXhPZiIsImZvbGRlZFBsYXllcnMiLCJhZGQiLCJwbGF5ZXJzIiwibmV4dFBsYXllckluZGV4IiwiaGFzIiwiZGVhbENhcmRzIiwic2h1ZmZsZWREZWNrIiwic3RhcnRpbmdQb3NpdGlvbiIsInBvc2l0aW9uIiwicGxheWVyQ2FyZHMiLCJwb3AiLCJwbGF5ZXJIYW5kIiwiam9pbiIsImRlYWx0IiwibmV4dF9wbGF5ZXIiLCJudW1QbGF5ZXJzIiwiaGlnaGVzdEJldCIsImJldCIsIm5leHRJbmRleCIsImZvbGRlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/gameUtils.ts\n"));

/***/ })

});