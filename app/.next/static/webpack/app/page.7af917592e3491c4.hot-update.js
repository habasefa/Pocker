"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/gameUtils.ts":
/*!********************************!*\
  !*** ./src/utils/gameUtils.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BIG_BLIND: () => (/* binding */ BIG_BLIND),\n/* harmony export */   community_cards: () => (/* binding */ community_cards),\n/* harmony export */   dealCards: () => (/* binding */ dealCards),\n/* harmony export */   gameStarter: () => (/* binding */ gameStarter),\n/* harmony export */   getNextPlayerIndex: () => (/* binding */ getNextPlayerIndex),\n/* harmony export */   next_actions: () => (/* binding */ next_actions),\n/* harmony export */   next_player: () => (/* binding */ next_player),\n/* harmony export */   should_continue_round: () => (/* binding */ should_continue_round),\n/* harmony export */   updateCards: () => (/* binding */ updateCards)\n/* harmony export */ });\nconst BIG_BLIND = 40;\nconst gameStarter = ()=>{\n    // 1. Position the players\n    const positions = [\n        1,\n        2,\n        3,\n        4,\n        5,\n        6\n    ];\n    // 2. Determine the dealer\n    const dealerIndex = Math.floor(Math.random() * positions.length);\n    // 3. Initialize the small blind and big blind\n    const dsb = {\n        dealer: {\n            player: positions[dealerIndex]\n        },\n        \"small blind\": {\n            player: positions[(dealerIndex + 1) % positions.length],\n            amount: BIG_BLIND / 2\n        },\n        \"big blind\": {\n            player: positions[(dealerIndex + 2) % positions.length],\n            amount: BIG_BLIND\n        }\n    };\n    // 4. Initialize a standard deck of 52 cards\n    const suits = [\n        \"hearts\",\n        \"diamonds\",\n        \"clubs\",\n        \"spades\"\n    ];\n    const values = [\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"10\",\n        \"J\",\n        \"Q\",\n        \"K\",\n        \"A\"\n    ];\n    let deck = suits.flatMap((suit)=>values.map((value)=>({\n                suit,\n                value\n            })));\n    // 5. Shuffle the deck\n    deck = deck.sort(()=>Math.random() - 0.5);\n    // 6. Deal cards (2 cards per player)\n    const dealtCards = {};\n    const playersCount = positions.length;\n    for(let i = 0; i < playersCount; i++){\n        dealtCards[positions[i]] = deck.slice(i * 2, i * 2 + 2);\n    }\n    // 7. Update remaining deck by removing dealt cards\n    const remainingDeck = deck.slice(playersCount * 2);\n    console.log(\"data\", dealCards);\n    // 8. Return game state with initial setup\n    return {\n        data: [],\n        dsb,\n        remainingDeck,\n        actions: {\n            preFlop: [],\n            flop: [],\n            turn: [],\n            river: []\n        }\n    };\n};\nconst community_cards = (round, deck)=>{\n    let cardsToDraw;\n    switch(round){\n        case \"flop\":\n            cardsToDraw = 3; // Draw 3 cards for the flop\n            break;\n        case \"turn\":\n        case \"river\":\n            cardsToDraw = 1; // Draw 1 card for turn and river\n            break;\n        default:\n            return {\n                cards: [],\n                remainingDeck: deck\n            }; // For preFlop or invalid rounds, return an empty set of cards\n    }\n    // Draw the specified number of cards from the deck\n    const drawnCards = deck.slice(0, cardsToDraw);\n    const remainingDeck = deck.slice(cardsToDraw);\n    return {\n        cards: drawnCards,\n        remainingDeck\n    };\n};\nconst updateCards = (state, round, playerIndex, action, amount)=>{\n    // Create a copy of the state to ensure immutability\n    const newState = {\n        ...state,\n        actions: {\n            ...state.actions\n        }\n    };\n    // Ensure the actions array for the specified round exists\n    if (!newState.actions[round]) {\n        newState.actions[round] = [];\n    }\n    // Add a new action entry to the round's actions array\n    newState.actions[round].push({\n        player: newState.data[playerIndex].player,\n        action,\n        ...amount !== undefined && {\n            amount\n        }\n    });\n    return newState;\n};\nconst next_actions = (actions, round, currentPlayerIndex)=>{\n    console.log(\"actions in next_actions\", actions);\n    // Extract actions taken in the specified round\n    const roundActions = actions[round] || [];\n    // Determine the highest bet made in the current round\n    const currentBet = Math.max(0, ...roundActions.filter((action)=>[\n            \"bet\",\n            \"raise\",\n            \"call\"\n        ].includes(action.action)).map((action)=>action.amount || 0));\n    // Calculate the total amount the current player has contributed in this round\n    const playerBet = roundActions.filter((action)=>action.playerIndex === currentPlayerIndex).reduce((sum, action)=>sum + (action.amount || 0), 0);\n    // Initialize possible actions for the player\n    const availableActions = [\n        \"fold\"\n    ];\n    // Determine available actions based on the current betting state\n    if (currentBet === 0) {\n        // No existing bet in the round: player can \"check\" or \"bet\"\n        availableActions.push(\"check\", \"bet\");\n    } else {\n        // There's an existing bet in the round\n        if (playerBet < currentBet) {\n            availableActions.push(\"call\"); // Player can call to match the current bet\n        }\n        if (playerBet === currentBet) {\n            availableActions.push(\"check\"); // Player can check if they’ve matched the bet\n        }\n        if (playerBet < currentBet) {\n            availableActions.push(\"raise\"); // Player can raise if they have chips to increase the current bet\n        }\n    }\n    // Add \"all-in\" as an option\n    availableActions.push(\"all-in\");\n    return availableActions;\n};\nconst should_continue_round = (actions, data, currentRound)=>{\n    // Get the list of actions for the current round\n    const roundActions = actions[currentRound];\n    // Check if every player in `data` has made an action in the current round\n    const allPlayersActed = data.every((player)=>roundActions.some((action)=>action.player === player.player));\n    // Calculate the total bet amount for each player in the current round\n    const playerBetTotals = {};\n    roundActions.forEach((action)=>{\n        if ([\n            \"bet\",\n            \"raise\",\n            \"call\"\n        ].includes(action.action) && action.amount !== undefined) {\n            playerBetTotals[action.player] = (playerBetTotals[action.player] || 0) + action.amount;\n        }\n    });\n    // Get all unique bet totals from players who acted in the round\n    const uniqueBetTotals = new Set(Object.values(playerBetTotals));\n    // All players must act, and their total bet amounts must be equal\n    return allPlayersActed && uniqueBetTotals.size === 1;\n};\nconst getNextPlayerIndex = (playerIndex, data, currentRound)=>{\n    const rounds = [\n        \"preFlop\",\n        \"flop\",\n        \"turn\",\n        \"river\"\n    ];\n    const currentRoundIndex = rounds.indexOf(currentRound);\n    // Step 1: Identify all players who have folded in any round up to the current round\n    const foldedPlayers = new Set();\n    for(let i = 0; i <= currentRoundIndex; i++){\n        const round = rounds[i];\n        if (data.actions[round]) {\n            data.actions[round].forEach((action)=>{\n                if (action.action === \"fold\") {\n                    foldedPlayers.add(action.player);\n                }\n            });\n        }\n    }\n    // Step 2: Find the next active player index\n    const players = data.players; // Assuming `data.players` is an array of player objects or IDs\n    let nextPlayerIndex = playerIndex;\n    do {\n        nextPlayerIndex = (nextPlayerIndex + 1) % players.length; // Move to the next player in a circular manner\n    }while (foldedPlayers.has(players[nextPlayerIndex]) && nextPlayerIndex !== playerIndex);\n    // If we looped back to the original playerIndex without finding an active player, return -1 (or handle as needed)\n    if (nextPlayerIndex === playerIndex && foldedPlayers.has(players[nextPlayerIndex])) {\n        return -1; // No eligible player found\n    }\n    return nextPlayerIndex;\n};\n// Helper function to generate dealt cards for each player\nconst dealCards = function() {\n    let players = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6, dealer = arguments.length > 1 ? arguments[1] : void 0;\n    const suits = [\n        \"♠\",\n        \"♥\",\n        \"♦\",\n        \"♣\"\n    ];\n    const values = [\n        \"A\",\n        \"K\",\n        \"Q\",\n        \"J\",\n        \"10\",\n        \"9\",\n        \"8\",\n        \"7\",\n        \"6\",\n        \"5\",\n        \"4\",\n        \"3\",\n        \"2\"\n    ];\n    // Generate a full deck of cards\n    const deck = [];\n    for (const suit of suits){\n        for (const value of values){\n            deck.push(\"\".concat(value).concat(suit));\n        }\n    }\n    // Shuffle the deck\n    const shuffledDeck = deck.sort(()=>Math.random() - 0.5);\n    // Deal two cards to each player, starting from the player after the dealer\n    const dealtCards = [];\n    const startingPosition = (dealer + 1) % players;\n    for(let i = 0; i < players; i++){\n        const position = (startingPosition + i) % players;\n        const playerCards = [\n            shuffledDeck.pop(),\n            shuffledDeck.pop()\n        ]; // Deal two cards per player\n        const playerHand = playerCards.join(\" \"); // Format as \"Ac Kh\"\n        dealtCards.push({\n            player: position + 1,\n            dealt: playerHand\n        });\n    }\n    // After dealing cards, the remaining deck is what's left in shuffledDeck\n    const remainingDeck = [\n        ...shuffledDeck\n    ];\n    return {\n        dealtCards,\n        remainingDeck\n    };\n};\n// Helper function to tell the next player to act\nconst next_player = (state, currentPlayerIndex)=>{\n    const { dealtCards } = state; // Access the list of players from the state\n    const numPlayers = dealtCards.length;\n    // Find the highest bet made in the current stage\n    const highestBet = Math.max(...dealtCards.map((player)=>player.bet || 0) // Assuming `bet` property stores each player’s current bet amount\n    );\n    // Start from the next player and loop until finding an eligible player\n    let nextIndex = (currentPlayerIndex + 1) % numPlayers;\n    while(nextIndex !== currentPlayerIndex){\n        const player = dealtCards[nextIndex];\n        // Check if player has not folded and their bet is not equal to the highest bet\n        if (!player.folded && (player.bet || 0) < highestBet) {\n            return nextIndex; // Return the index of the next player to act\n        }\n        // Move to the next player\n        nextIndex = (nextIndex + 1) % numPlayers;\n    }\n    // If no eligible player found, return -1 to indicate the round is complete\n    return -1;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9nYW1lVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRU8sTUFBTUEsWUFBWSxHQUFHO0FBQ3JCLE1BQU1DLGNBQWM7SUFDekIsMEJBQTBCO0lBQzFCLE1BQU1DLFlBQVk7UUFBQztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7S0FBRTtJQUVwQywwQkFBMEI7SUFDMUIsTUFBTUMsY0FBY0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUtKLFVBQVVLLE1BQU07SUFFL0QsOENBQThDO0lBQzlDLE1BQU1DLE1BQU07UUFDVkMsUUFBUTtZQUFFQyxRQUFRUixTQUFTLENBQUNDLFlBQVk7UUFBQztRQUN6QyxlQUFlO1lBQ2JPLFFBQVFSLFNBQVMsQ0FBQyxDQUFDQyxjQUFjLEtBQUtELFVBQVVLLE1BQU0sQ0FBQztZQUN2REksUUFBUVgsWUFBWTtRQUN0QjtRQUNBLGFBQWE7WUFDWFUsUUFBUVIsU0FBUyxDQUFDLENBQUNDLGNBQWMsS0FBS0QsVUFBVUssTUFBTSxDQUFDO1lBQ3ZESSxRQUFRWDtRQUNWO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsTUFBTVksUUFBUTtRQUFDO1FBQVU7UUFBWTtRQUFTO0tBQVM7SUFDdkQsTUFBTUMsU0FBUztRQUNiO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDRCxJQUFJQyxPQUFPRixNQUFNRyxPQUFPLENBQUMsQ0FBQ0MsT0FBU0gsT0FBT0ksR0FBRyxDQUFDLENBQUNDLFFBQVc7Z0JBQUVGO2dCQUFNRTtZQUFNO0lBRXhFLHNCQUFzQjtJQUN0QkosT0FBT0EsS0FBS0ssSUFBSSxDQUFDLElBQU1mLEtBQUtFLE1BQU0sS0FBSztJQUV2QyxxQ0FBcUM7SUFDckMsTUFBTWMsYUFBZ0UsQ0FBQztJQUN2RSxNQUFNQyxlQUFlbkIsVUFBVUssTUFBTTtJQUNyQyxJQUFLLElBQUll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QjtRQUN2QyxNQUFNckMsU0FBU1UsVUFBVSxDQUFDcUUsVUFBVTtRQUVwQywrRUFBK0U7UUFDL0UsSUFBSSxDQUFDL0UsT0FBT2dGLE1BQU0sSUFBSSxDQUFDaEYsT0FBTzhFLEdBQUcsSUFBSSxLQUFLRCxZQUFZO1lBQ3BELE9BQU9FLFdBQVcsNkNBQTZDO1FBQ2pFO1FBRUEsMEJBQTBCO1FBQzFCQSxZQUFZLENBQUNBLFlBQVksS0FBS0g7SUFDaEM7SUFFQSwyRUFBMkU7SUFDM0UsT0FBTyxDQUFDO0FBQ1YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlscy9nYW1lVXRpbHMudHM/NWI5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBY3Rpb24sIFJvdW5kIH0gZnJvbSBcIkAvYXBwL3BhZ2VcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBCSUdfQkxJTkQgPSA0MDtcclxuZXhwb3J0IGNvbnN0IGdhbWVTdGFydGVyID0gKCkgPT4ge1xyXG4gIC8vIDEuIFBvc2l0aW9uIHRoZSBwbGF5ZXJzXHJcbiAgY29uc3QgcG9zaXRpb25zID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xyXG5cclxuICAvLyAyLiBEZXRlcm1pbmUgdGhlIGRlYWxlclxyXG4gIGNvbnN0IGRlYWxlckluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9zaXRpb25zLmxlbmd0aCk7XHJcblxyXG4gIC8vIDMuIEluaXRpYWxpemUgdGhlIHNtYWxsIGJsaW5kIGFuZCBiaWcgYmxpbmRcclxuICBjb25zdCBkc2IgPSB7XHJcbiAgICBkZWFsZXI6IHsgcGxheWVyOiBwb3NpdGlvbnNbZGVhbGVySW5kZXhdIH0sXHJcbiAgICBcInNtYWxsIGJsaW5kXCI6IHtcclxuICAgICAgcGxheWVyOiBwb3NpdGlvbnNbKGRlYWxlckluZGV4ICsgMSkgJSBwb3NpdGlvbnMubGVuZ3RoXSxcclxuICAgICAgYW1vdW50OiBCSUdfQkxJTkQgLyAyLFxyXG4gICAgfSxcclxuICAgIFwiYmlnIGJsaW5kXCI6IHtcclxuICAgICAgcGxheWVyOiBwb3NpdGlvbnNbKGRlYWxlckluZGV4ICsgMikgJSBwb3NpdGlvbnMubGVuZ3RoXSxcclxuICAgICAgYW1vdW50OiBCSUdfQkxJTkQsXHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIC8vIDQuIEluaXRpYWxpemUgYSBzdGFuZGFyZCBkZWNrIG9mIDUyIGNhcmRzXHJcbiAgY29uc3Qgc3VpdHMgPSBbXCJoZWFydHNcIiwgXCJkaWFtb25kc1wiLCBcImNsdWJzXCIsIFwic3BhZGVzXCJdO1xyXG4gIGNvbnN0IHZhbHVlcyA9IFtcclxuICAgIFwiMlwiLFxyXG4gICAgXCIzXCIsXHJcbiAgICBcIjRcIixcclxuICAgIFwiNVwiLFxyXG4gICAgXCI2XCIsXHJcbiAgICBcIjdcIixcclxuICAgIFwiOFwiLFxyXG4gICAgXCI5XCIsXHJcbiAgICBcIjEwXCIsXHJcbiAgICBcIkpcIixcclxuICAgIFwiUVwiLFxyXG4gICAgXCJLXCIsXHJcbiAgICBcIkFcIixcclxuICBdO1xyXG4gIGxldCBkZWNrID0gc3VpdHMuZmxhdE1hcCgoc3VpdCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+ICh7IHN1aXQsIHZhbHVlIH0pKSk7XHJcblxyXG4gIC8vIDUuIFNodWZmbGUgdGhlIGRlY2tcclxuICBkZWNrID0gZGVjay5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xyXG5cclxuICAvLyA2LiBEZWFsIGNhcmRzICgyIGNhcmRzIHBlciBwbGF5ZXIpXHJcbiAgY29uc3QgZGVhbHRDYXJkczogUmVjb3JkPG51bWJlciwgeyBzdWl0OiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfVtdPiA9IHt9O1xyXG4gIGNvbnN0IHBsYXllcnNDb3VudCA9IHBvc2l0aW9ucy5sZW5ndGg7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGF5ZXJzQ291bnQ7IGkrKykge1xyXG4gICAgZGVhbHRDYXJkc1twb3NpdGlvbnNbaV1dID0gZGVjay5zbGljZShpICogMiwgaSAqIDIgKyAyKTtcclxuICB9XHJcblxyXG4gIC8vIDcuIFVwZGF0ZSByZW1haW5pbmcgZGVjayBieSByZW1vdmluZyBkZWFsdCBjYXJkc1xyXG4gIGNvbnN0IHJlbWFpbmluZ0RlY2sgPSBkZWNrLnNsaWNlKHBsYXllcnNDb3VudCAqIDIpO1xyXG5cclxuICBjb25zb2xlLmxvZyhcImRhdGFcIiwgZGVhbENhcmRzKTtcclxuXHJcbiAgLy8gOC4gUmV0dXJuIGdhbWUgc3RhdGUgd2l0aCBpbml0aWFsIHNldHVwXHJcbiAgcmV0dXJuIHtcclxuICAgIGRhdGE6IFtdLFxyXG4gICAgZHNiLFxyXG4gICAgcmVtYWluaW5nRGVjayxcclxuICAgIGFjdGlvbnM6IHtcclxuICAgICAgcHJlRmxvcDogW10sXHJcbiAgICAgIGZsb3A6IFtdLFxyXG4gICAgICB0dXJuOiBbXSxcclxuICAgICAgcml2ZXI6IFtdLFxyXG4gICAgfSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbW11bml0eV9jYXJkcyA9IChyb3VuZDogUm91bmQsIGRlY2s6IHN0cmluZ1tdKSA9PiB7XHJcbiAgbGV0IGNhcmRzVG9EcmF3O1xyXG5cclxuICBzd2l0Y2ggKHJvdW5kKSB7XHJcbiAgICBjYXNlIFwiZmxvcFwiOlxyXG4gICAgICBjYXJkc1RvRHJhdyA9IDM7IC8vIERyYXcgMyBjYXJkcyBmb3IgdGhlIGZsb3BcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwidHVyblwiOlxyXG4gICAgY2FzZSBcInJpdmVyXCI6XHJcbiAgICAgIGNhcmRzVG9EcmF3ID0gMTsgLy8gRHJhdyAxIGNhcmQgZm9yIHR1cm4gYW5kIHJpdmVyXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIHsgY2FyZHM6IFtdLCByZW1haW5pbmdEZWNrOiBkZWNrIH07IC8vIEZvciBwcmVGbG9wIG9yIGludmFsaWQgcm91bmRzLCByZXR1cm4gYW4gZW1wdHkgc2V0IG9mIGNhcmRzXHJcbiAgfVxyXG5cclxuICAvLyBEcmF3IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNhcmRzIGZyb20gdGhlIGRlY2tcclxuICBjb25zdCBkcmF3bkNhcmRzID0gZGVjay5zbGljZSgwLCBjYXJkc1RvRHJhdyk7XHJcbiAgY29uc3QgcmVtYWluaW5nRGVjayA9IGRlY2suc2xpY2UoY2FyZHNUb0RyYXcpO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgY2FyZHM6IGRyYXduQ2FyZHMsXHJcbiAgICByZW1haW5pbmdEZWNrLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlQ2FyZHMgPSAoXHJcbiAgc3RhdGU6IGFueSxcclxuICByb3VuZDogc3RyaW5nLFxyXG4gIHBsYXllckluZGV4OiBudW1iZXIsXHJcbiAgYWN0aW9uOiBzdHJpbmcsXHJcbiAgYW1vdW50PzogbnVtYmVyXHJcbikgPT4ge1xyXG4gIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHN0YXRlIHRvIGVuc3VyZSBpbW11dGFiaWxpdHlcclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgYWN0aW9uczogeyAuLi5zdGF0ZS5hY3Rpb25zIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gRW5zdXJlIHRoZSBhY3Rpb25zIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIHJvdW5kIGV4aXN0c1xyXG4gIGlmICghbmV3U3RhdGUuYWN0aW9uc1tyb3VuZF0pIHtcclxuICAgIG5ld1N0YXRlLmFjdGlvbnNbcm91bmRdID0gW107XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgYSBuZXcgYWN0aW9uIGVudHJ5IHRvIHRoZSByb3VuZCdzIGFjdGlvbnMgYXJyYXlcclxuICBuZXdTdGF0ZS5hY3Rpb25zW3JvdW5kXS5wdXNoKHtcclxuICAgIHBsYXllcjogbmV3U3RhdGUuZGF0YVtwbGF5ZXJJbmRleF0ucGxheWVyLFxyXG4gICAgYWN0aW9uLFxyXG4gICAgLi4uKGFtb3VudCAhPT0gdW5kZWZpbmVkICYmIHsgYW1vdW50IH0pLCAvLyBDb25kaXRpb25hbGx5IGFkZCBhbW91bnQgaWYgcHJvdmlkZWRcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59O1xyXG5leHBvcnQgY29uc3QgbmV4dF9hY3Rpb25zID0gKFxyXG4gIGFjdGlvbnM6IHtcclxuICAgIFtrZXkgaW4gUm91bmRdOiBBcnJheTx7XHJcbiAgICAgIHBsYXllckluZGV4OiBudW1iZXI7XHJcbiAgICAgIGFjdGlvbjogc3RyaW5nO1xyXG4gICAgICBhbW91bnQ/OiBudW1iZXI7XHJcbiAgICB9PjtcclxuICB9LFxyXG4gIHJvdW5kOiBSb3VuZCxcclxuICBjdXJyZW50UGxheWVySW5kZXg6IG51bWJlclxyXG4pOiBBY3Rpb25bXSA9PiB7XHJcbiAgY29uc29sZS5sb2coXCJhY3Rpb25zIGluIG5leHRfYWN0aW9uc1wiLCBhY3Rpb25zKTtcclxuICAvLyBFeHRyYWN0IGFjdGlvbnMgdGFrZW4gaW4gdGhlIHNwZWNpZmllZCByb3VuZFxyXG4gIGNvbnN0IHJvdW5kQWN0aW9ucyA9IGFjdGlvbnNbcm91bmRdIHx8IFtdO1xyXG5cclxuICAvLyBEZXRlcm1pbmUgdGhlIGhpZ2hlc3QgYmV0IG1hZGUgaW4gdGhlIGN1cnJlbnQgcm91bmRcclxuICBjb25zdCBjdXJyZW50QmV0ID0gTWF0aC5tYXgoXHJcbiAgICAwLFxyXG4gICAgLi4ucm91bmRBY3Rpb25zXHJcbiAgICAgIC5maWx0ZXIoKGFjdGlvbikgPT4gW1wiYmV0XCIsIFwicmFpc2VcIiwgXCJjYWxsXCJdLmluY2x1ZGVzKGFjdGlvbi5hY3Rpb24pKVxyXG4gICAgICAubWFwKChhY3Rpb24pID0+IGFjdGlvbi5hbW91bnQgfHwgMClcclxuICApO1xyXG5cclxuICAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIGFtb3VudCB0aGUgY3VycmVudCBwbGF5ZXIgaGFzIGNvbnRyaWJ1dGVkIGluIHRoaXMgcm91bmRcclxuICBjb25zdCBwbGF5ZXJCZXQgPSByb3VuZEFjdGlvbnNcclxuICAgIC5maWx0ZXIoKGFjdGlvbikgPT4gYWN0aW9uLnBsYXllckluZGV4ID09PSBjdXJyZW50UGxheWVySW5kZXgpXHJcbiAgICAucmVkdWNlKChzdW0sIGFjdGlvbikgPT4gc3VtICsgKGFjdGlvbi5hbW91bnQgfHwgMCksIDApO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBvc3NpYmxlIGFjdGlvbnMgZm9yIHRoZSBwbGF5ZXJcclxuICBjb25zdCBhdmFpbGFibGVBY3Rpb25zOiBBY3Rpb25bXSA9IFtcImZvbGRcIl07XHJcblxyXG4gIC8vIERldGVybWluZSBhdmFpbGFibGUgYWN0aW9ucyBiYXNlZCBvbiB0aGUgY3VycmVudCBiZXR0aW5nIHN0YXRlXHJcbiAgaWYgKGN1cnJlbnRCZXQgPT09IDApIHtcclxuICAgIC8vIE5vIGV4aXN0aW5nIGJldCBpbiB0aGUgcm91bmQ6IHBsYXllciBjYW4gXCJjaGVja1wiIG9yIFwiYmV0XCJcclxuICAgIGF2YWlsYWJsZUFjdGlvbnMucHVzaChcImNoZWNrXCIsIFwiYmV0XCIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBUaGVyZSdzIGFuIGV4aXN0aW5nIGJldCBpbiB0aGUgcm91bmRcclxuICAgIGlmIChwbGF5ZXJCZXQgPCBjdXJyZW50QmV0KSB7XHJcbiAgICAgIGF2YWlsYWJsZUFjdGlvbnMucHVzaChcImNhbGxcIik7IC8vIFBsYXllciBjYW4gY2FsbCB0byBtYXRjaCB0aGUgY3VycmVudCBiZXRcclxuICAgIH1cclxuICAgIGlmIChwbGF5ZXJCZXQgPT09IGN1cnJlbnRCZXQpIHtcclxuICAgICAgYXZhaWxhYmxlQWN0aW9ucy5wdXNoKFwiY2hlY2tcIik7IC8vIFBsYXllciBjYW4gY2hlY2sgaWYgdGhleeKAmXZlIG1hdGNoZWQgdGhlIGJldFxyXG4gICAgfVxyXG4gICAgaWYgKHBsYXllckJldCA8IGN1cnJlbnRCZXQpIHtcclxuICAgICAgYXZhaWxhYmxlQWN0aW9ucy5wdXNoKFwicmFpc2VcIik7IC8vIFBsYXllciBjYW4gcmFpc2UgaWYgdGhleSBoYXZlIGNoaXBzIHRvIGluY3JlYXNlIHRoZSBjdXJyZW50IGJldFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIFwiYWxsLWluXCIgYXMgYW4gb3B0aW9uXHJcbiAgYXZhaWxhYmxlQWN0aW9ucy5wdXNoKFwiYWxsLWluXCIpO1xyXG5cclxuICByZXR1cm4gYXZhaWxhYmxlQWN0aW9ucztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzaG91bGRfY29udGludWVfcm91bmQgPSAoXHJcbiAgYWN0aW9uczoge1xyXG4gICAgW2tleSBpbiBSb3VuZF06IEFycmF5PHsgcGxheWVyOiBzdHJpbmc7IGFjdGlvbjogc3RyaW5nOyBhbW91bnQ/OiBudW1iZXIgfT47XHJcbiAgfSxcclxuICBkYXRhOiBhbnlbXSxcclxuICBjdXJyZW50Um91bmQ6IFJvdW5kXHJcbikgPT4ge1xyXG4gIC8vIEdldCB0aGUgbGlzdCBvZiBhY3Rpb25zIGZvciB0aGUgY3VycmVudCByb3VuZFxyXG4gIGNvbnN0IHJvdW5kQWN0aW9ucyA9IGFjdGlvbnNbY3VycmVudFJvdW5kXTtcclxuXHJcbiAgLy8gQ2hlY2sgaWYgZXZlcnkgcGxheWVyIGluIGBkYXRhYCBoYXMgbWFkZSBhbiBhY3Rpb24gaW4gdGhlIGN1cnJlbnQgcm91bmRcclxuICBjb25zdCBhbGxQbGF5ZXJzQWN0ZWQgPSBkYXRhLmV2ZXJ5KChwbGF5ZXIpID0+XHJcbiAgICByb3VuZEFjdGlvbnMuc29tZSgoYWN0aW9uKSA9PiBhY3Rpb24ucGxheWVyID09PSBwbGF5ZXIucGxheWVyKVxyXG4gICk7XHJcblxyXG4gIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgYmV0IGFtb3VudCBmb3IgZWFjaCBwbGF5ZXIgaW4gdGhlIGN1cnJlbnQgcm91bmRcclxuICBjb25zdCBwbGF5ZXJCZXRUb3RhbHM6IHsgW3BsYXllcjogc3RyaW5nXTogbnVtYmVyIH0gPSB7fTtcclxuXHJcbiAgcm91bmRBY3Rpb25zLmZvckVhY2goKGFjdGlvbikgPT4ge1xyXG4gICAgaWYgKFxyXG4gICAgICBbXCJiZXRcIiwgXCJyYWlzZVwiLCBcImNhbGxcIl0uaW5jbHVkZXMoYWN0aW9uLmFjdGlvbikgJiZcclxuICAgICAgYWN0aW9uLmFtb3VudCAhPT0gdW5kZWZpbmVkXHJcbiAgICApIHtcclxuICAgICAgcGxheWVyQmV0VG90YWxzW2FjdGlvbi5wbGF5ZXJdID1cclxuICAgICAgICAocGxheWVyQmV0VG90YWxzW2FjdGlvbi5wbGF5ZXJdIHx8IDApICsgYWN0aW9uLmFtb3VudDtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gR2V0IGFsbCB1bmlxdWUgYmV0IHRvdGFscyBmcm9tIHBsYXllcnMgd2hvIGFjdGVkIGluIHRoZSByb3VuZFxyXG4gIGNvbnN0IHVuaXF1ZUJldFRvdGFscyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhwbGF5ZXJCZXRUb3RhbHMpKTtcclxuXHJcbiAgLy8gQWxsIHBsYXllcnMgbXVzdCBhY3QsIGFuZCB0aGVpciB0b3RhbCBiZXQgYW1vdW50cyBtdXN0IGJlIGVxdWFsXHJcbiAgcmV0dXJuIGFsbFBsYXllcnNBY3RlZCAmJiB1bmlxdWVCZXRUb3RhbHMuc2l6ZSA9PT0gMTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXROZXh0UGxheWVySW5kZXggPSAoXHJcbiAgcGxheWVySW5kZXg6IG51bWJlcixcclxuICBkYXRhOiBhbnksXHJcbiAgY3VycmVudFJvdW5kOiBSb3VuZFxyXG4pID0+IHtcclxuICBjb25zdCByb3VuZHMgPSBbXCJwcmVGbG9wXCIsIFwiZmxvcFwiLCBcInR1cm5cIiwgXCJyaXZlclwiXTtcclxuICBjb25zdCBjdXJyZW50Um91bmRJbmRleCA9IHJvdW5kcy5pbmRleE9mKGN1cnJlbnRSb3VuZCk7XHJcblxyXG4gIC8vIFN0ZXAgMTogSWRlbnRpZnkgYWxsIHBsYXllcnMgd2hvIGhhdmUgZm9sZGVkIGluIGFueSByb3VuZCB1cCB0byB0aGUgY3VycmVudCByb3VuZFxyXG4gIGNvbnN0IGZvbGRlZFBsYXllcnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gY3VycmVudFJvdW5kSW5kZXg7IGkrKykge1xyXG4gICAgY29uc3Qgcm91bmQgPSByb3VuZHNbaV07XHJcbiAgICBpZiAoZGF0YS5hY3Rpb25zW3JvdW5kXSkge1xyXG4gICAgICBkYXRhLmFjdGlvbnNbcm91bmRdLmZvckVhY2goXHJcbiAgICAgICAgKGFjdGlvbjogeyBwbGF5ZXI6IHN0cmluZzsgYWN0aW9uOiBzdHJpbmcgfSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGFjdGlvbi5hY3Rpb24gPT09IFwiZm9sZFwiKSB7XHJcbiAgICAgICAgICAgIGZvbGRlZFBsYXllcnMuYWRkKGFjdGlvbi5wbGF5ZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFN0ZXAgMjogRmluZCB0aGUgbmV4dCBhY3RpdmUgcGxheWVyIGluZGV4XHJcbiAgY29uc3QgcGxheWVycyA9IGRhdGEucGxheWVyczsgLy8gQXNzdW1pbmcgYGRhdGEucGxheWVyc2AgaXMgYW4gYXJyYXkgb2YgcGxheWVyIG9iamVjdHMgb3IgSURzXHJcbiAgbGV0IG5leHRQbGF5ZXJJbmRleCA9IHBsYXllckluZGV4O1xyXG5cclxuICBkbyB7XHJcbiAgICBuZXh0UGxheWVySW5kZXggPSAobmV4dFBsYXllckluZGV4ICsgMSkgJSBwbGF5ZXJzLmxlbmd0aDsgLy8gTW92ZSB0byB0aGUgbmV4dCBwbGF5ZXIgaW4gYSBjaXJjdWxhciBtYW5uZXJcclxuICB9IHdoaWxlIChcclxuICAgIGZvbGRlZFBsYXllcnMuaGFzKHBsYXllcnNbbmV4dFBsYXllckluZGV4XSkgJiZcclxuICAgIG5leHRQbGF5ZXJJbmRleCAhPT0gcGxheWVySW5kZXhcclxuICApO1xyXG5cclxuICAvLyBJZiB3ZSBsb29wZWQgYmFjayB0byB0aGUgb3JpZ2luYWwgcGxheWVySW5kZXggd2l0aG91dCBmaW5kaW5nIGFuIGFjdGl2ZSBwbGF5ZXIsIHJldHVybiAtMSAob3IgaGFuZGxlIGFzIG5lZWRlZClcclxuICBpZiAoXHJcbiAgICBuZXh0UGxheWVySW5kZXggPT09IHBsYXllckluZGV4ICYmXHJcbiAgICBmb2xkZWRQbGF5ZXJzLmhhcyhwbGF5ZXJzW25leHRQbGF5ZXJJbmRleF0pXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gLTE7IC8vIE5vIGVsaWdpYmxlIHBsYXllciBmb3VuZFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5leHRQbGF5ZXJJbmRleDtcclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBkZWFsdCBjYXJkcyBmb3IgZWFjaCBwbGF5ZXJcclxuZXhwb3J0IGNvbnN0IGRlYWxDYXJkcyA9IChwbGF5ZXJzID0gNiwgZGVhbGVyOiBudW1iZXIpID0+IHtcclxuICBjb25zdCBzdWl0cyA9IFtcIuKZoFwiLCBcIuKZpVwiLCBcIuKZplwiLCBcIuKZo1wiXTtcclxuICBjb25zdCB2YWx1ZXMgPSBbXHJcbiAgICBcIkFcIixcclxuICAgIFwiS1wiLFxyXG4gICAgXCJRXCIsXHJcbiAgICBcIkpcIixcclxuICAgIFwiMTBcIixcclxuICAgIFwiOVwiLFxyXG4gICAgXCI4XCIsXHJcbiAgICBcIjdcIixcclxuICAgIFwiNlwiLFxyXG4gICAgXCI1XCIsXHJcbiAgICBcIjRcIixcclxuICAgIFwiM1wiLFxyXG4gICAgXCIyXCIsXHJcbiAgXTtcclxuXHJcbiAgLy8gR2VuZXJhdGUgYSBmdWxsIGRlY2sgb2YgY2FyZHNcclxuICBjb25zdCBkZWNrID0gW107XHJcbiAgZm9yIChjb25zdCBzdWl0IG9mIHN1aXRzKSB7XHJcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xyXG4gICAgICBkZWNrLnB1c2goYCR7dmFsdWV9JHtzdWl0fWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2h1ZmZsZSB0aGUgZGVja1xyXG4gIGNvbnN0IHNodWZmbGVkRGVjayA9IGRlY2suc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcclxuXHJcbiAgLy8gRGVhbCB0d28gY2FyZHMgdG8gZWFjaCBwbGF5ZXIsIHN0YXJ0aW5nIGZyb20gdGhlIHBsYXllciBhZnRlciB0aGUgZGVhbGVyXHJcbiAgY29uc3QgZGVhbHRDYXJkcyA9IFtdO1xyXG4gIGNvbnN0IHN0YXJ0aW5nUG9zaXRpb24gPSAoZGVhbGVyICsgMSkgJSBwbGF5ZXJzO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYXllcnM7IGkrKykge1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSAoc3RhcnRpbmdQb3NpdGlvbiArIGkpICUgcGxheWVycztcclxuICAgIGNvbnN0IHBsYXllckNhcmRzID0gW3NodWZmbGVkRGVjay5wb3AoKSwgc2h1ZmZsZWREZWNrLnBvcCgpXTsgLy8gRGVhbCB0d28gY2FyZHMgcGVyIHBsYXllclxyXG4gICAgY29uc3QgcGxheWVySGFuZCA9IHBsYXllckNhcmRzLmpvaW4oXCIgXCIpOyAvLyBGb3JtYXQgYXMgXCJBYyBLaFwiXHJcbiAgICBkZWFsdENhcmRzLnB1c2goe1xyXG4gICAgICBwbGF5ZXI6IHBvc2l0aW9uICsgMSwgLy8gQXNzdW1pbmcgcG9zaXRpb25zIGFyZSAxLWluZGV4ZWQgKDEsIDIsIC4uLiwgNilcclxuICAgICAgZGVhbHQ6IHBsYXllckhhbmQsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIEFmdGVyIGRlYWxpbmcgY2FyZHMsIHRoZSByZW1haW5pbmcgZGVjayBpcyB3aGF0J3MgbGVmdCBpbiBzaHVmZmxlZERlY2tcclxuICBjb25zdCByZW1haW5pbmdEZWNrID0gWy4uLnNodWZmbGVkRGVja107XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBkZWFsdENhcmRzLFxyXG4gICAgcmVtYWluaW5nRGVjayxcclxuICB9O1xyXG59O1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHRlbGwgdGhlIG5leHQgcGxheWVyIHRvIGFjdFxyXG5leHBvcnQgY29uc3QgbmV4dF9wbGF5ZXIgPSAoc3RhdGU6IGFueSwgY3VycmVudFBsYXllckluZGV4OiBudW1iZXIpID0+IHtcclxuICBjb25zdCB7IGRlYWx0Q2FyZHMgfSA9IHN0YXRlOyAvLyBBY2Nlc3MgdGhlIGxpc3Qgb2YgcGxheWVycyBmcm9tIHRoZSBzdGF0ZVxyXG4gIGNvbnN0IG51bVBsYXllcnMgPSBkZWFsdENhcmRzLmxlbmd0aDtcclxuXHJcbiAgLy8gRmluZCB0aGUgaGlnaGVzdCBiZXQgbWFkZSBpbiB0aGUgY3VycmVudCBzdGFnZVxyXG4gIGNvbnN0IGhpZ2hlc3RCZXQgPSBNYXRoLm1heChcclxuICAgIC4uLmRlYWx0Q2FyZHMubWFwKChwbGF5ZXIpID0+IHBsYXllci5iZXQgfHwgMCkgLy8gQXNzdW1pbmcgYGJldGAgcHJvcGVydHkgc3RvcmVzIGVhY2ggcGxheWVy4oCZcyBjdXJyZW50IGJldCBhbW91bnRcclxuICApO1xyXG5cclxuICAvLyBTdGFydCBmcm9tIHRoZSBuZXh0IHBsYXllciBhbmQgbG9vcCB1bnRpbCBmaW5kaW5nIGFuIGVsaWdpYmxlIHBsYXllclxyXG4gIGxldCBuZXh0SW5kZXggPSAoY3VycmVudFBsYXllckluZGV4ICsgMSkgJSBudW1QbGF5ZXJzO1xyXG5cclxuICB3aGlsZSAobmV4dEluZGV4ICE9PSBjdXJyZW50UGxheWVySW5kZXgpIHtcclxuICAgIGNvbnN0IHBsYXllciA9IGRlYWx0Q2FyZHNbbmV4dEluZGV4XTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIG5vdCBmb2xkZWQgYW5kIHRoZWlyIGJldCBpcyBub3QgZXF1YWwgdG8gdGhlIGhpZ2hlc3QgYmV0XHJcbiAgICBpZiAoIXBsYXllci5mb2xkZWQgJiYgKHBsYXllci5iZXQgfHwgMCkgPCBoaWdoZXN0QmV0KSB7XHJcbiAgICAgIHJldHVybiBuZXh0SW5kZXg7IC8vIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG5leHQgcGxheWVyIHRvIGFjdFxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgcGxheWVyXHJcbiAgICBuZXh0SW5kZXggPSAobmV4dEluZGV4ICsgMSkgJSBudW1QbGF5ZXJzO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgbm8gZWxpZ2libGUgcGxheWVyIGZvdW5kLCByZXR1cm4gLTEgdG8gaW5kaWNhdGUgdGhlIHJvdW5kIGlzIGNvbXBsZXRlXHJcbiAgcmV0dXJuIC0xO1xyXG59O1xyXG4iXSwibmFtZXMiOlsiQklHX0JMSU5EIiwiZ2FtZVN0YXJ0ZXIiLCJwb3NpdGlvbnMiLCJkZWFsZXJJbmRleCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImxlbmd0aCIsImRzYiIsImRlYWxlciIsInBsYXllciIsImFtb3VudCIsInN1aXRzIiwidmFsdWVzIiwiZGVjayIsImZsYXRNYXAiLCJzdWl0IiwibWFwIiwidmFsdWUiLCJzb3J0IiwiZGVhbHRDYXJkcyIsInBsYXllcnNDb3VudCIsImkiLCJzbGljZSIsInJlbWFpbmluZ0RlY2siLCJjb25zb2xlIiwibG9nIiwiZGVhbENhcmRzIiwiZGF0YSIsImFjdGlvbnMiLCJwcmVGbG9wIiwiZmxvcCIsInR1cm4iLCJyaXZlciIsImNvbW11bml0eV9jYXJkcyIsInJvdW5kIiwiY2FyZHNUb0RyYXciLCJjYXJkcyIsImRyYXduQ2FyZHMiLCJ1cGRhdGVDYXJkcyIsInN0YXRlIiwicGxheWVySW5kZXgiLCJhY3Rpb24iLCJuZXdTdGF0ZSIsInB1c2giLCJ1bmRlZmluZWQiLCJuZXh0X2FjdGlvbnMiLCJjdXJyZW50UGxheWVySW5kZXgiLCJyb3VuZEFjdGlvbnMiLCJjdXJyZW50QmV0IiwibWF4IiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJwbGF5ZXJCZXQiLCJyZWR1Y2UiLCJzdW0iLCJhdmFpbGFibGVBY3Rpb25zIiwic2hvdWxkX2NvbnRpbnVlX3JvdW5kIiwiY3VycmVudFJvdW5kIiwiYWxsUGxheWVyc0FjdGVkIiwiZXZlcnkiLCJzb21lIiwicGxheWVyQmV0VG90YWxzIiwiZm9yRWFjaCIsInVuaXF1ZUJldFRvdGFscyIsIlNldCIsIk9iamVjdCIsInNpemUiLCJnZXROZXh0UGxheWVySW5kZXgiLCJyb3VuZHMiLCJjdXJyZW50Um91bmRJbmRleCIsImluZGV4T2YiLCJmb2xkZWRQbGF5ZXJzIiwiYWRkIiwicGxheWVycyIsIm5leHRQbGF5ZXJJbmRleCIsImhhcyIsInNodWZmbGVkRGVjayIsInN0YXJ0aW5nUG9zaXRpb24iLCJwb3NpdGlvbiIsInBsYXllckNhcmRzIiwicG9wIiwicGxheWVySGFuZCIsImpvaW4iLCJkZWFsdCIsIm5leHRfcGxheWVyIiwibnVtUGxheWVycyIsImhpZ2hlc3RCZXQiLCJiZXQiLCJuZXh0SW5kZXgiLCJmb2xkZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/gameUtils.ts\n"));

/***/ })

});